<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mcollina/mosca#readme"

    >mosca (v2.3.0)</a>
</h1>
<h4>MQTT broker as a module</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca">module mosca</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer">
            function <span class="apidocSignatureSpan">mosca.</span>Authorizer
            <span class="apidocSignatureSpan">(users)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server">
            function <span class="apidocSignatureSpan">mosca.</span>Server
            <span class="apidocSignatureSpan">(opts, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Stats">
            function <span class="apidocSignatureSpan">mosca.</span>Stats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.abstract">
            function <span class="apidocSignatureSpan">mosca.</span>abstract
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client">
            function <span class="apidocSignatureSpan">mosca.</span>client
            <span class="apidocSignatureSpan">(conn, server)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.matcher">
            function <span class="apidocSignatureSpan">mosca.</span>matcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.Memory
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.Mongo
            <span class="apidocSignatureSpan">(options, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.Redis
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>Authorizer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>Stats.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>interfaces</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.Memory.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.Mongo.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.Redis.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>serializers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Authorizer">module mosca.Authorizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.Authorizer">
            function <span class="apidocSignatureSpan">mosca.</span>Authorizer
            <span class="apidocSignatureSpan">(users)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Authorizer.prototype">module mosca.Authorizer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype._authenticate">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>_authenticate
            <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.addUser">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>addUser
            <span class="apidocSignatureSpan">(user, pass, authorizePublish, authorizeSubscribe, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.authenticate">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authenticate
            <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.authorizePublish">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizePublish
            <span class="apidocSignatureSpan">(client, topic, payload, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.authorizeSubscribe">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizeSubscribe
            <span class="apidocSignatureSpan">(client, topic, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.rmUser">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>rmUser
            <span class="apidocSignatureSpan">(user, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Server">module mosca.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.Server">
            function <span class="apidocSignatureSpan">mosca.</span>Server
            <span class="apidocSignatureSpan">(opts, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Server.prototype">module mosca.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.attachHttpServer">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>attachHttpServer
            <span class="apidocSignatureSpan">(server, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authenticate">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authenticate
            <span class="apidocSignatureSpan">(client, username, password, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authorizeForward">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeForward
            <span class="apidocSignatureSpan">(client, packet, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authorizePublish">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizePublish
            <span class="apidocSignatureSpan">(client, topic, payload, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authorizeSubscribe">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeSubscribe
            <span class="apidocSignatureSpan">(client, topic, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.close">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.forwardOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardOfflinePackets
            <span class="apidocSignatureSpan">(client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.forwardRetained">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardRetained
            <span class="apidocSignatureSpan">(pattern, client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.generateUniqueId">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>generateUniqueId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.nextDedupId">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>nextDedupId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.persistClient">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>persistClient
            <span class="apidocSignatureSpan">(client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.publish">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>publish
            <span class="apidocSignatureSpan">(packet, client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.published">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>published
            <span class="apidocSignatureSpan">(packet, client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.restoreClientSubscriptions">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>restoreClientSubscriptions
            <span class="apidocSignatureSpan">(client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.storePacket">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>storePacket
            <span class="apidocSignatureSpan">(packet, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.subscribe">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(topic, callback, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.toString">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, originMessageId, packet, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Stats">module mosca.Stats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Stats.Stats">
            function <span class="apidocSignatureSpan">mosca.</span>Stats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Stats.prototype">module mosca.Stats.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Stats.prototype.wire">
            function <span class="apidocSignatureSpan">mosca.Stats.prototype.</span>wire
            <span class="apidocSignatureSpan">(server)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.abstract">module mosca.abstract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.abstract.abstract">
            function <span class="apidocSignatureSpan">mosca.</span>abstract
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.abstract.super_">
            function <span class="apidocSignatureSpan">mosca.abstract.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.client">module mosca.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.client">
            function <span class="apidocSignatureSpan">mosca.</span>client
            <span class="apidocSignatureSpan">(conn, server)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.client.prototype">module mosca.client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype._buildForward">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_buildForward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype._setup">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.close">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>close
            <span class="apidocSignatureSpan">(callback, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleAuthorizePublish">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizePublish
            <span class="apidocSignatureSpan">(err, success, packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleAuthorizeSubscribe">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizeSubscribe
            <span class="apidocSignatureSpan">(err, success, s, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleConnect">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleConnect
            <span class="apidocSignatureSpan">(packet, completeConnection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handlePingreq">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePingreq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handlePuback">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePuback
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleSubscribe">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleSubscribe
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.onNonDisconnectClose">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>onNonDisconnectClose
            <span class="apidocSignatureSpan">(reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.setUpTimer">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>setUpTimer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.unsubscribeMapTo">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>unsubscribeMapTo
            <span class="apidocSignatureSpan">(topic, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.interfaces">module mosca.interfaces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.buildServe">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildServe
            <span class="apidocSignatureSpan">(iface, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.buildWrap">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildWrap
            <span class="apidocSignatureSpan">(mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.httpFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.httpsFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpsFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.mqttFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.mqttsFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttsFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.serverFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>serverFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.matcher">module mosca.matcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.matcher.matcher">
            function <span class="apidocSignatureSpan">mosca.</span>matcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.matcher.super_">
            function <span class="apidocSignatureSpan">mosca.matcher.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.options">module mosca.options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.defaultsLegacy">
            function <span class="apidocSignatureSpan">mosca.options.</span>defaultsLegacy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.defaultsModern">
            function <span class="apidocSignatureSpan">mosca.options.</span>defaultsModern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.modernize">
            function <span class="apidocSignatureSpan">mosca.options.</span>modernize
            <span class="apidocSignatureSpan">(legacy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.populate">
            function <span class="apidocSignatureSpan">mosca.options.</span>populate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.validate">
            function <span class="apidocSignatureSpan">mosca.options.</span>validate
            <span class="apidocSignatureSpan">(opts, validationOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence">module mosca.persistence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
            <span class="apidocSignatureSpan">(options, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.getFactory">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>getFactory
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.LevelUp">module mosca.persistence.LevelUp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.LevelUp">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.LevelUp.prototype">module mosca.persistence.LevelUp.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype._cleanupStream">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_cleanupStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype._storePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_storePacket
            <span class="apidocSignatureSpan">(client, packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupRetained
            <span class="apidocSignatureSpan">(pattern, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeOfflinePacket
            <span class="apidocSignatureSpan">(packet, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeRetained
            <span class="apidocSignatureSpan">(packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.streamOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>streamOfflinePackets
            <span class="apidocSignatureSpan">(client, cb, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.LevelUp.super_.prototype">module mosca.persistence.LevelUp.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.wire">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>wire
            <span class="apidocSignatureSpan">(server)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Memory">module mosca.persistence.Memory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory.Memory">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.Memory.</span>super_
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Memory.prototype">module mosca.persistence.Memory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.Memory.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Mongo">module mosca.persistence.Mongo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.Mongo">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
            <span class="apidocSignatureSpan">(options, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Mongo.prototype">module mosca.persistence.Mongo.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype._storePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>_storePacket
            <span class="apidocSignatureSpan">(client, packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupRetained
            <span class="apidocSignatureSpan">(pattern, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.storeOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeOfflinePacket
            <span class="apidocSignatureSpan">(packet, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.storeRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeRetained
            <span class="apidocSignatureSpan">(packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.storeSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.streamOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>streamOfflinePackets
            <span class="apidocSignatureSpan">(client, cb, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, packet, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Redis">module mosca.persistence.Redis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.Redis">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Redis.prototype">module mosca.persistence.Redis.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._buildClient">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_buildClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._cleanClient">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_cleanClient
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._explicitlyClosed">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_explicitlyClosed
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._storePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_storePacket
            <span class="apidocSignatureSpan">(client, packet, pipeline, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>close
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.lookupRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupRetained
            <span class="apidocSignatureSpan">(pattern, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.lookupSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupSubscriptions
            <span class="apidocSignatureSpan">(client, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.storeOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeOfflinePacket
            <span class="apidocSignatureSpan">(packet, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.storeRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeRetained
            <span class="apidocSignatureSpan">(packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.storeSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeSubscriptions
            <span class="apidocSignatureSpan">(client, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.streamOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>streamOfflinePackets
            <span class="apidocSignatureSpan">(client, cb, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.serializers">module mosca.serializers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.serializers.clientSerializer">
            function <span class="apidocSignatureSpan">mosca.serializers.</span>clientSerializer
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.serializers.packetSerializer">
            function <span class="apidocSignatureSpan">mosca.serializers.</span>packetSerializer
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.utils">module mosca.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.utils.topicPatterns">
            function <span class="apidocSignatureSpan">mosca.utils.</span>topicPatterns
            <span class="apidocSignatureSpan">(topic)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca" id="apidoc.module.mosca">module mosca</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Authorizer" id="apidoc.element.mosca.Authorizer">
        function <span class="apidocSignatureSpan">mosca.</span>Authorizer
        <span class="apidocSignatureSpan">(users)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Authorizer(users) {
  this.users = users || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var steed = require(&#x22;steed&#x22;);

describe(&#x22;mosca.Authorizer&#x22;, function() {

  var authorizer, instance, client;

  beforeEach(function() {
authorizer = new mosca.<span class="apidocCodeKeywordSpan">Authorizer</span>();
client = {};
  });

  describe(&#x22;authenticate&#x22;, function() {

beforeEach(function() {
  instance = authorizer.authenticate;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server" id="apidoc.element.mosca.Server">
        function <span class="apidocSignatureSpan">mosca.</span>Server
        <span class="apidocSignatureSpan">(opts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(opts, callback) {
  var modernOpts = options.modernize(opts);
  var validationResult = options.validate(modernOpts);

  if (validationResult.errors.length &#x3e; 0) {
    var errMessage = validationResult.errors[0].message;
    if (callback) {
      callback(new Error(errMessage));
    } else {
      throw new Error(errMessage);
    }
  }

  modernOpts = options.populate(modernOpts);

  if (!(this instanceof Server)) {
    return new Server(opts, callback);
  }

  EventEmitter.call(this);

  if (true) { // REFACTOR: kludge for tests that rely on options structure
    this.opts = extend(true, {}, defaults, opts);
    this.modernOpts = modernOpts;

    if (this.opts.secure) {
      this.opts.secure.port = this.opts.secure.port || 8883;
    }
    if (this.opts.http) {
      this.opts.http.port = this.opts.http.port || 3000;
    }
    if (this.opts.https) {
      this.opts.https.port = this.opts.https.port || 3001;
    }
  } else { // REFACTOR: enable this once test are updated
    this.opts = modernOpts;
  }

  callback = callback || function() {};

  this._dedupId = 0;
  this.clients = {};
  this.closed = false;

  if (this.modernOpts.logger.childOf) {
    this.logger = this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.name;
    this.logger = this.logger.child(this.modernOpts.logger);
  } else {
    this.logger = pino(this.modernOpts.logger);
  }

  if(this.modernOpts.stats) {
    new Stats().wire(this);
  }

  var that = this;

  // each Server has a dummy id for logging purposes
  this.id = this.modernOpts.id || shortid.generate();

  // initialize servers list
  this.servers = [];


  steed.series([

    // steed.series: wait for ascoltatore
    function (done) {

      if(that.modernOpts.ascoltatore) {
        that.ascoltatore = that.modernOpts.ascoltatore;
        done();
      }
      else {
        that.ascoltatore = ascoltatori.build(that.modernOpts.backend, done);
        that.ascoltatore.on(&#x27;error&#x27;, that.emit.bind(that, &#x27;error&#x27;));
      }
    },

    // steed.series: wait for persistence

    function (done) {
      // REFACTOR: partially move to options.validate and options.populate?
      var persistenceFactory = that.modernOpts.persistence &#x26;&#x26; that.modernOpts.persistence.factory;
      if (persistenceFactory) {
        if (typeof persistenceFactory === &#x27;string&#x27;) {
          var factoryName = persistenceFactory;
          persistenceFactory = persistence.getFactory(factoryName);
          if (!persistenceFactory) {
            return callback(new Error(&#x27;No persistence factory found for &#x27; + factoryName ));
          }
        }

        that.persistence = persistenceFactory(that.modernOpts.persistence, done);
        that.persistence.wire(that);
      } else {
        that.persistence = null;
        done();
      }
    },

    // steed.series: iterate over defined interfaces, build servers and listen
    function (done) {

      steed.eachSeries(that.modernOpts.interfaces, function (iface, dn) {
        var fallback = that.modernOpts;
        var host = iface.host || that.modernOpts.host;
        var port = iface.port || that.modernOpts.port;

        var server = interfaces.serverFactory(iface, fallback, that);
        that.servers.push(server);
        server.maxConnections = iface.maxConnections || 10000000;
        server.listen(port, host, dn);
      }, done);
    },

    // steed.series: log startup information
    function (done) {
      var logInfo = {};

      that.modernOpts.interfaces.forEach(function (iface) {
        var name = iface.type;
        if (typeof name !== &#x22;string&#x22;) {
          name = iface.type.name;
        }
        logInfo[name] = iface.port;
      });

      that.logger.info(logInfo, &#x22;server started&#x22;);
      that.emit(&#x22;ready&#x22;);
      done(null);
    }
  ], function(err, results){
    if(err) {
      callback(err);
    }
  });

  that.on(&#x22;clientConnected&#x22;, function(client) {
    if(that.modernOpts.publishNewClient) {
      that.publish({
        topic: &#x22;$SYS/&#x22; + that.id + &#x22;/new/clients&#x22;,
        payload: client.id ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var settings = {
  port: 1883,
  backend: ascoltatore
};

var server = new mosca.<span class="apidocCodeKeywordSpan">Server</span>(settings);

server.on(&#x27;clientConnected&#x27;, function(client) {
    console.log(&#x27;client connected&#x27;, client.id);
});

// fired when a message is received
server.on(&#x27;published&#x27;, function(packet, client) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Stats" id="apidoc.element.mosca.Stats">
        function <span class="apidocSignatureSpan">mosca.</span>Stats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats() {
  if (!(this instanceof Stats)) {
    return new Stats();
  }

  this.maxConnectedClients = 0;
  this.connectedClients = 0;
  this.lastIntervalConnectedClients = 0;
  this.publishedMessages = 0;
  this.lastIntervalPublishedMessages = 0;
  this.started = new Date();

  this.load = {
    m15: new Load(15),
    m5: new Load(5),
    m1: new Load(1)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var clock;
var interval = 10;

beforeEach(function() {
  clock = sinon.useFakeTimers();
  server = new EventEmitter();
  server.id = 42;
  instance = new mosca.<span class="apidocCodeKeywordSpan">Stats</span>();
  instance.wire(server);

  server.publish = function(packet) {
    server.emit(&#x22;testPublished&#x22;, packet);
  };
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.abstract" id="apidoc.element.mosca.abstract">
        function <span class="apidocSignatureSpan">mosca.</span>abstract
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client" id="apidoc.element.mosca.client">
        function <span class="apidocSignatureSpan">mosca.</span>client
        <span class="apidocSignatureSpan">(conn, server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(conn, server) {
  this.connection = conn;
  this.server = server;
  this.logger = server.logger;
  this.subscriptions = {};

  this.nextId = 1;
  this.inflight = {};
  this.inflightCounter = 0;
  this._lastDedupId = -1;
  this._closed = false;
  this._closing = false;

  this._setup();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.matcher" id="apidoc.element.mosca.matcher">
        function <span class="apidocSignatureSpan">mosca.</span>matcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matcher() {
  Qlobber.call(this, { separator: &#x22;/&#x22;, wildcard_one: &#x22;+&#x22; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp" id="apidoc.element.mosca.persistence.LevelUp">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel(&#x22;retained&#x22;);
  this._clientSubscriptions = db.sublevel(&#x22;clientSubscriptions&#x22;);
  this._subscriptions = db.sublevel(&#x22;subscriptions&#x22;);
  this._offlinePackets = db.sublevel(&#x22;offlinePackets&#x22;);
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on(&#x22;data&#x22;, function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory" id="apidoc.element.mosca.persistence.Memory">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.Memory
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryPersistence(options, callback) {
  if (!(this instanceof MemoryPersistence)) {
    return new MemoryPersistence(options, callback);
  }

  options = options || {};
  options.db = factory;
  options.path = &#x22;RAM&#x22;;
  LevelUpPersistence.call(this, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo" id="apidoc.element.mosca.persistence.Mongo">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.Mongo
        <span class="apidocSignatureSpan">(options, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongoPersistence(options, done) {
  if (!(this instanceof MongoPersistence)) {
    return new MongoPersistence(options, done);
  }


  this.options = extend(true, {}, defaults, options);
  this.options.mongo.safe = true;

  // This offlineMessageTimeout(in milliseconds) can set the maximum life time for stored offline messages. This is a
  // Mongo-only feature which relies on TTL index. Since Mongo checks expired entries on a minute-based clock, the
  // actual lifetime is ceil(offlineMessageTimeout/60000) minutes. For this reason, we do not have an unit test
  // for this feature.
  if (options.offlineMessageTimeout) {
    this.options.ttl.packets = options.offlineMessageTimeout;
  }

  var that = this;

  var connected = function(err, db) {
    if (err) {
      if (done) {
        return done(err);
      }
      // we have no way of providing an error handler
      throw err;
    }

    that.db = db;
    steed.parallel([
      function(cb) {
        db.collection(&#x22;subscriptions&#x22;, function(err, coll) {
          that._subscriptions = coll;
          steed.parallel([
            that._subscriptions.ensureIndex.bind(that._subscriptions, &#x22;client&#x22;),
            that._subscriptions.ensureIndex.bind(that._subscriptions, { &#x22;added&#x22;: 1 }, { expireAfterSeconds: Math.round(that.options
.ttl.subscriptions / 1000 )} )
          ], cb);
        });
      },
      function(cb) {
        db.collection(&#x22;packets&#x22;, function(err, coll) {
          if (err) {
            return cb(err);
          }

          that._packets = coll;
          steed.series([
            that._packets.ensureIndex.bind(that._packets, &#x22;client&#x22;),
            function(cb){
              // Check expiration indexes. If not exist, create; If exist but with different TTL, delete and recreate; Otherwise
, do nothing.
              that._packets.indexes(function(error, colIndexes){
                if (error) {
                  cb(error);
                } else {
                  var addedIndexKey = {&#x22;added&#x22;: 1};
                  var addedIndexKeyString = &#x27;added_1&#x27;; // If addedIndex changes, this value should also be changed accordingly.
                  var addedIndexObj = colIndexes.filter(function(obj){
                    return obj.name == addedIndexKeyString;
                  });
                  var packetTTLInSeconds = Math.round(that.options.ttl.packets / 1000);
                  if (addedIndexObj.length &#x3c;= 0 || addedIndexObj[0].expireAfterSeconds != packetTTLInSeconds) {
                    if (addedIndexObj.length &#x3e; 0) {
                      // Different index TTL, recreate index to make sure the TTL is set to the new number.
                      that._packets.dropIndex(addedIndexKeyString, function (error, result){
                        if (error) {
                          cb(error);
                        } else {
                          that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                        }
                      });
                    } else {
                      // Create Index for the first time.
                      that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                    }
                  } else {
                    cb(null);
                  }
                }
              });
            }
          ], cb);
        });
      },
      function(cb) {
        db.collection(&#x22;retained&#x22;, function(err, coll) {
          that._retained = coll;
          that._retained.ensureIndex(&#x22;topic&#x22;, { unique: true }, cb);
        });
      }
    ], function(err) {
      if (done) {
        done(err, that);
      }
    });
  };

  // Connect to the db
  if (options.connection) {
    connected(null, this.options.connection);
  } else {
    MongoClient.connect(this.options.url, this.options.mongo, connected);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis" id="apidoc.element.mosca.persistence.Redis">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.Redis
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisPersistence(options, callback) {
  if (!(this instanceof RedisPersistence)) {
    return new RedisPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);

  this._subMatcher = new Matcher();

  this._client = this._buildClient();
  this._pubSubClient = this._buildClient();
  this._id = shortid.generate();

  this._packetKeyTTL = this.options.ttl.packets;
  this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key
  this._closing = false;
  this._closed = false;

  var fetchAndUpdateLocalSub = function(key, unsubs, retried, cb) {
    that._client.get(key, function(err, result) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          return;
        }
      }

      var subs = JSON.parse(result);
      if (!result || typeof subs !== &#x27;object&#x27;) {
        if (!retried) {
          setTimeout(fetchAndUpdateLocalSub.bind(null, key, unsubs, true, cb), 500);
        } else {
          cb &#x26;&#x26; cb();
        }
        return;
      }

      updateLocalSub(key, subs, unsubs);

      if (cb) {
        cb();
      }
    });
  };

  var updateLocalSub = function(key, subs, unsubs) {
    var xs = key.split(&#x22;:&#x22;);
    var id = key.substr(xs[0].length + xs[1].length + 2);

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.add(sub, id);
    });

    if( unsubs ) {
      unsubs.forEach(function(unsub) {
        that._subMatcher.remove(unsub, id);
      });
    }
  };

  var that = this;

  this._pubSubClient.subscribe(this.options.channel, function(){
    if (that._explicitlyClosed()) {
      return;
    }
    var subsStream = that._client.scanStream({
      match: &#x22;client:sub:*&#x22;,
      count: 25000
    });
    var pipeline = that._client.pipeline();
    var total = 0;
    var done = null;

    subsStream.on(&#x27;data&#x27;, function(moreKeys){
      total += moreKeys.length;
      moreKeys.map(function(k){
        pipeline.get(k, function(err, result) {
          if (err) {
            done &#x26;&#x26; done(err);
            return;
          }
          var subs = JSON.parse(result);
          if (!result || typeof subs !== &#x27;object&#x27;) {
            done &#x26;&#x26; done();
            return;
          }
          updateLocalSub(k, subs);
          done &#x26;&#x26; done();
        });
      });
    });

    subsStream.on(&#x27;end&#x27;, function(){
      if (total === 0) {
        return callback(null, that);
      }
      done = function() {
        if (--total === 0 &#x26;&#x26; callback) {
          callback(null, that);
          callback = null;
        }
      };
      pipeline.exec();
    });
  });

  this._pubSubClient.on(&#x22;message&#x22;, function(channel, message) {
    if (that._explicitlyClosed()) {
      return;
    }
    var parsed = JSON.parse(message);
    if (parsed.process !== that._id) {
      updateLocalSub(parsed.key, parsed.subs, parsed.unsubs);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Authorizer" id="apidoc.module.mosca.Authorizer">module mosca.Authorizer</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Authorizer.Authorizer" id="apidoc.element.mosca.Authorizer.Authorizer">
        function <span class="apidocSignatureSpan">mosca.</span>Authorizer
        <span class="apidocSignatureSpan">(users)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Authorizer(users) {
  this.users = users || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var steed = require(&#x22;steed&#x22;);

describe(&#x22;mosca.Authorizer&#x22;, function() {

  var authorizer, instance, client;

  beforeEach(function() {
authorizer = new mosca.<span class="apidocCodeKeywordSpan">Authorizer</span>();
client = {};
  });

  describe(&#x22;authenticate&#x22;, function() {

beforeEach(function() {
  instance = authorizer.authenticate;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Authorizer.prototype" id="apidoc.module.mosca.Authorizer.prototype">module mosca.Authorizer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype._authenticate" id="apidoc.element.mosca.Authorizer.prototype._authenticate">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>_authenticate
        <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_authenticate = function (client, user, pass, cb) {

  var missingUser = !user || !pass || !this.users[user];

  if (missingUser) {
    cb(null, false);
    return;
  }

  user = user.toString();

  client.user = user;
  user = this.users[user];

  hasher({
    password: pass.toString(),
    salt: user.salt
  }, function(err, pass, salt, hash) {
    if (err) {
      cb(err);
      return;
    }

    var success = (user.hash === hash);
    cb(null, success);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* It returns the authenticate function to plug into mosca.Server.
*
* @api public
*/
Authorizer.prototype.__defineGetter__(&#x22;authenticate&#x22;, function() {
 var that = this;
 return function(client, user, pass, cb) {
   that.<span class="apidocCodeKeywordSpan">_authenticate</span>(client, user, pass, cb);
 };
});

/**
* It returns the authorizePublish function to plug into mosca.Server.
*
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.addUser" id="apidoc.element.mosca.Authorizer.prototype.addUser">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>addUser
        <span class="apidocSignatureSpan">(user, pass, authorizePublish, authorizeSubscribe, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUser = function (user, pass, authorizePublish, authorizeSubscribe, cb) {
  var that = this;

  if (typeof authorizePublish === &#x22;function&#x22;) {
    cb = authorizePublish;
    authorizePublish = null;
    authorizeSubscribe = null;
  } else if (typeof authorizeSubscribe == &#x22;function&#x22;) {
    cb = authorizeSubscribe;
    authorizeSubscribe = null;
  }

  if (!authorizePublish) {
    authorizePublish = defaultGlob;
  }

  if (!authorizeSubscribe) {
    authorizeSubscribe = defaultGlob;
  }

  hasher({
    password: pass.toString()
  }, function(err, pass, salt, hash) {
    if (!err) {
      that.users[user] = {
        salt: salt,
        hash: hash,
        authorizePublish: authorizePublish,
        authorizeSubscribe: authorizeSubscribe
      };
    }
    cb(err);
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
  });
}

function adduser(username, password) {
  runned = true;
  loadAuthorizerAndSave(function(err, authorizer, done) {
    authorizer.<span class="apidocCodeKeywordSpan">addUser</span>(username, password, program.authorizePublish,
                       program.authorizeSubscribe, done);
  });
}

function rmuser(username) {
  runned = true;
  loadAuthorizerAndSave(function(err, authorizer, done) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.authenticate" id="apidoc.element.mosca.Authorizer.prototype.authenticate">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authenticate
        <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authenticate = function (client, user, pass, cb) {
  that._authenticate(client, user, pass, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  client.stream.end();
  return;
}
  }


  that.server.<span class="apidocCodeKeywordSpan">authenticate</span>(this, packet.username, packet.password,
                       function(err, verdict) {

if (err) {
  logger.info({ username: packet.username }, &#x22;authentication error&#x22;);
  client.connack({
    returnCode: 4
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.authorizePublish" id="apidoc.element.mosca.Authorizer.prototype.authorizePublish">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizePublish
        <span class="apidocSignatureSpan">(client, topic, payload, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizePublish = function (client, topic, payload, cb) {
  cb(null, minimatch(topic, that.users[client.user].authorizePublish || defaultGlob));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
client.on(&#x22;subscribe&#x22;, function(packet) {
  that.setUpTimer();
  that.handleSubscribe(packet);
});

client.on(&#x22;publish&#x22;, function(packet) {
  that.setUpTimer();
  that.server.<span class="apidocCodeKeywordSpan">authorizePublish</span>(that, packet.topic, packet.payload, function(err, success
) {
    that.handleAuthorizePublish(err, success, packet);
  });
});

client.on(&#x22;unsubscribe&#x22;, function(packet) {
  that.setUpTimer();
  that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.authorizeSubscribe" id="apidoc.element.mosca.Authorizer.prototype.authorizeSubscribe">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizeSubscribe
        <span class="apidocSignatureSpan">(client, topic, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizeSubscribe = function (client, topic, cb) {
  cb(null, minimatch(topic, that.users[client.user].authorizeSubscribe || defaultGlob));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};

function handleEachSub (s, cb) {
  /*jshint validthis:true */
  var that = this;
  if (this.subscriptions[s.topic] === undefined) {
    this.server.<span class="apidocCodeKeywordSpan">authorizeSubscribe</span>(that, s.topic, function(err, success) {
      that.handleAuthorizeSubscribe(err, success, s, cb);
    });
  } else {
    cb(null, true);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.rmUser" id="apidoc.element.mosca.Authorizer.prototype.rmUser">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>rmUser
        <span class="apidocSignatureSpan">(user, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmUser = function (user, cb) {
  delete this.users[user];
  cb();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                       program.authorizeSubscribe, done);
  });
}

function rmuser(username) {
  runned = true;
  loadAuthorizerAndSave(function(err, authorizer, done) {
    authorizer.<span class="apidocCodeKeywordSpan">rmUser</span>(username, done);
  });
}

program.
  command(&#x22;adduser &#x3c;user&#x3e; &#x3c;pass&#x3e;&#x22;).
  description(&#x22;Add a user to the given credentials file&#x22;).
  action(adduser);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Server" id="apidoc.module.mosca.Server">module mosca.Server</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Server.Server" id="apidoc.element.mosca.Server.Server">
        function <span class="apidocSignatureSpan">mosca.</span>Server
        <span class="apidocSignatureSpan">(opts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(opts, callback) {
  var modernOpts = options.modernize(opts);
  var validationResult = options.validate(modernOpts);

  if (validationResult.errors.length &#x3e; 0) {
    var errMessage = validationResult.errors[0].message;
    if (callback) {
      callback(new Error(errMessage));
    } else {
      throw new Error(errMessage);
    }
  }

  modernOpts = options.populate(modernOpts);

  if (!(this instanceof Server)) {
    return new Server(opts, callback);
  }

  EventEmitter.call(this);

  if (true) { // REFACTOR: kludge for tests that rely on options structure
    this.opts = extend(true, {}, defaults, opts);
    this.modernOpts = modernOpts;

    if (this.opts.secure) {
      this.opts.secure.port = this.opts.secure.port || 8883;
    }
    if (this.opts.http) {
      this.opts.http.port = this.opts.http.port || 3000;
    }
    if (this.opts.https) {
      this.opts.https.port = this.opts.https.port || 3001;
    }
  } else { // REFACTOR: enable this once test are updated
    this.opts = modernOpts;
  }

  callback = callback || function() {};

  this._dedupId = 0;
  this.clients = {};
  this.closed = false;

  if (this.modernOpts.logger.childOf) {
    this.logger = this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.name;
    this.logger = this.logger.child(this.modernOpts.logger);
  } else {
    this.logger = pino(this.modernOpts.logger);
  }

  if(this.modernOpts.stats) {
    new Stats().wire(this);
  }

  var that = this;

  // each Server has a dummy id for logging purposes
  this.id = this.modernOpts.id || shortid.generate();

  // initialize servers list
  this.servers = [];


  steed.series([

    // steed.series: wait for ascoltatore
    function (done) {

      if(that.modernOpts.ascoltatore) {
        that.ascoltatore = that.modernOpts.ascoltatore;
        done();
      }
      else {
        that.ascoltatore = ascoltatori.build(that.modernOpts.backend, done);
        that.ascoltatore.on(&#x27;error&#x27;, that.emit.bind(that, &#x27;error&#x27;));
      }
    },

    // steed.series: wait for persistence

    function (done) {
      // REFACTOR: partially move to options.validate and options.populate?
      var persistenceFactory = that.modernOpts.persistence &#x26;&#x26; that.modernOpts.persistence.factory;
      if (persistenceFactory) {
        if (typeof persistenceFactory === &#x27;string&#x27;) {
          var factoryName = persistenceFactory;
          persistenceFactory = persistence.getFactory(factoryName);
          if (!persistenceFactory) {
            return callback(new Error(&#x27;No persistence factory found for &#x27; + factoryName ));
          }
        }

        that.persistence = persistenceFactory(that.modernOpts.persistence, done);
        that.persistence.wire(that);
      } else {
        that.persistence = null;
        done();
      }
    },

    // steed.series: iterate over defined interfaces, build servers and listen
    function (done) {

      steed.eachSeries(that.modernOpts.interfaces, function (iface, dn) {
        var fallback = that.modernOpts;
        var host = iface.host || that.modernOpts.host;
        var port = iface.port || that.modernOpts.port;

        var server = interfaces.serverFactory(iface, fallback, that);
        that.servers.push(server);
        server.maxConnections = iface.maxConnections || 10000000;
        server.listen(port, host, dn);
      }, done);
    },

    // steed.series: log startup information
    function (done) {
      var logInfo = {};

      that.modernOpts.interfaces.forEach(function (iface) {
        var name = iface.type;
        if (typeof name !== &#x22;string&#x22;) {
          name = iface.type.name;
        }
        logInfo[name] = iface.port;
      });

      that.logger.info(logInfo, &#x22;server started&#x22;);
      that.emit(&#x22;ready&#x22;);
      done(null);
    }
  ], function(err, results){
    if(err) {
      callback(err);
    }
  });

  that.on(&#x22;clientConnected&#x22;, function(client) {
    if(that.modernOpts.publishNewClient) {
      that.publish({
        topic: &#x22;$SYS/&#x22; + that.id + &#x22;/new/clients&#x22;,
        payload: client.id ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var settings = {
  port: 1883,
  backend: ascoltatore
};

var server = new mosca.<span class="apidocCodeKeywordSpan">Server</span>(settings);

server.on(&#x27;clientConnected&#x27;, function(client) {
    console.log(&#x27;client connected&#x27;, client.id);
});

// fired when a message is received
server.on(&#x27;published&#x27;, function(packet, client) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Server.prototype" id="apidoc.module.mosca.Server.prototype">module mosca.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.attachHttpServer" id="apidoc.element.mosca.Server.prototype.attachHttpServer">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>attachHttpServer
        <span class="apidocSignatureSpan">(server, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachHttpServer = function (server, path) {
  var that = this;

  var opt = { server: server };
  if (path) {
    opt.path = path;
  }

  ws.createServer(opt, function(stream) {
    var conn = new Connection(stream);
    new Client(conn, that);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return tls.createServer(credentials, buildWrap(mosca));
}

function httpFactory(iface, fallback, mosca) {
var serve = buildServe(iface, mosca);
var server = http.createServer(serve);

mosca.<span class="apidocCodeKeywordSpan">attachHttpServer</span>(server);
return server;
}

function httpsFactory(iface, fallback, mosca) {
var credentials = iface.credentials || fallback.credentials;
if (credentials === undefined) {
  throw new Error(&#x22;missing credentials for https server&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authenticate" id="apidoc.element.mosca.Server.prototype.authenticate">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authenticate
        <span class="apidocSignatureSpan">(client, username, password, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authenticate = function (client, username, password, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  client.stream.end();
  return;
}
  }


  that.server.<span class="apidocCodeKeywordSpan">authenticate</span>(this, packet.username, packet.password,
                       function(err, verdict) {

if (err) {
  logger.info({ username: packet.username }, &#x22;authentication error&#x22;);
  client.connack({
    returnCode: 4
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authorizeForward" id="apidoc.element.mosca.Server.prototype.authorizeForward">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeForward
        <span class="apidocSignatureSpan">(client, packet, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizeForward = function (client, packet, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var that = this;

  function doForward(err, packet) {
    if (err) {
return that.client &#x26;&#x26; that.client.emit(&#x27;error&#x27;, err);
    }

    that.server.<span class="apidocCodeKeywordSpan">authorizeForward</span>(that, packet, function(err, authorized) {
if (err) {
  return that.client &#x26;&#x26; that.client.emit(&#x27;error&#x27;, err);
}

if (!authorized) {
  that.logger.warn(packet, &#x22;Unauthorized Forward&#x22;);
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authorizePublish" id="apidoc.element.mosca.Server.prototype.authorizePublish">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizePublish
        <span class="apidocSignatureSpan">(client, topic, payload, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizePublish = function (client, topic, payload, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
client.on(&#x22;subscribe&#x22;, function(packet) {
  that.setUpTimer();
  that.handleSubscribe(packet);
});

client.on(&#x22;publish&#x22;, function(packet) {
  that.setUpTimer();
  that.server.<span class="apidocCodeKeywordSpan">authorizePublish</span>(that, packet.topic, packet.payload, function(err, success
) {
    that.handleAuthorizePublish(err, success, packet);
  });
});

client.on(&#x22;unsubscribe&#x22;, function(packet) {
  that.setUpTimer();
  that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authorizeSubscribe" id="apidoc.element.mosca.Server.prototype.authorizeSubscribe">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeSubscribe
        <span class="apidocSignatureSpan">(client, topic, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizeSubscribe = function (client, topic, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};

function handleEachSub (s, cb) {
  /*jshint validthis:true */
  var that = this;
  if (this.subscriptions[s.topic] === undefined) {
    this.server.<span class="apidocCodeKeywordSpan">authorizeSubscribe</span>(that, s.topic, function(err, success) {
      that.handleAuthorizeSubscribe(err, success, s, cb);
    });
  } else {
    cb(null, true);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.close" id="apidoc.element.mosca.Server.prototype.close">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  var that = this;
  var stuffToClose = [];

  callback = callback || function nop() {};

  if (that.closed) {
    return callback();
  }

  that.closed = true;

  Object.keys(that.clients).forEach(function(i) {
    stuffToClose.push(that.clients[i]);
  });

  that.servers.forEach(function(server) {
    stuffToClose.push(server);
  });

  if (that.persistence) {
    stuffToClose.push(that.persistence);
  }

  steed.each(stuffToClose, function(toClose, cb) {
    toClose.close(cb, &#x22;server closed&#x22;);
  }, function() {
    that.ascoltatore.close(function () {
      that.logger.info(&#x22;server closed&#x22;);
      that.emit(&#x22;closed&#x22;);
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.deleteOfflinePacket" id="apidoc.element.mosca.Server.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, &#x22;puback&#x22;);
if (this.inflight[packet.messageId]) {
  this.server.emit(&#x22;delivered&#x22;, this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &#x26;&#x26; that.client.emit(&#x22;error&#x22;, err);
    }
    logger.debug({ packet: packet }, &#x22;cleaned offline packet&#x22;);
  });
} else {
  logger.info({ packet: packet }, &#x22;no matching packet&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.forwardOfflinePackets" id="apidoc.element.mosca.Server.prototype.forwardOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardOfflinePackets
        <span class="apidocSignatureSpan">(client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forwardOfflinePackets = function (client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sessionPresent: session_present ? true : false
  });

  that.logger.info(&#x22;client connected&#x22;);
  that.server.emit(&#x22;clientConnected&#x22;, that);

  // packets will be forward only if client.clean is false
  that.server.<span class="apidocCodeKeywordSpan">forwardOfflinePackets</span>(that);
});

client.on(&#x22;puback&#x22;, function(packet) {
  that.setUpTimer();
  that.handlePuback(packet);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.forwardRetained" id="apidoc.element.mosca.Server.prototype.forwardRetained">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardRetained
        <span class="apidocSignatureSpan">(pattern, client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forwardRetained = function (pattern, client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return;
}

that.server.persistClient(that);

packet.subscriptions.forEach(function(sub, index) {
  if (authorized[index]) {
    that.server.<span class="apidocCodeKeywordSpan">forwardRetained</span>(sub.topic, that);
    that.server.emit(&#x22;subscribed&#x22;, sub.topic, that);
  } else {
    granted[index] = 0x80;
  }
});

if(!that._closed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.generateUniqueId" id="apidoc.element.mosca.Server.prototype.generateUniqueId">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>generateUniqueId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateUniqueId = function () {
  return shortid.generate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!callback) {
  callback = nop;
}

var newPacket = {
  topic: packet.topic,
  payload: packet.payload,
  messageId: this.<span class="apidocCodeKeywordSpan">generateUniqueId</span>(),
  qos: packet.qos,
  retain: packet.retain
};

var opts = {
  qos: packet.qos,
  messageId: newPacket.messageId
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.nextDedupId" id="apidoc.element.mosca.Server.prototype.nextDedupId">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>nextDedupId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextDedupId = function () {
  return this._dedupId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              indexPlus &#x3e;= 0 &#x26;&#x26;
              indexPlus &#x3c; 2
            )
          );

    if (forward) {
if (options._dedupId === undefined) {
  options._dedupId = that.server.<span class="apidocCodeKeywordSpan">nextDedupId</span>();
  that._lastDedupId = options._dedupId;
}

if (qos &#x26;&#x26; options.messageId) {
  that.server.updateOfflinePacket(that, options.messageId, packet, doForward);
} else {
  doForward(null, packet);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.persistClient" id="apidoc.element.mosca.Server.prototype.persistClient">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>persistClient
        <span class="apidocSignatureSpan">(client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persistClient = function (client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
  steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
    if (err) {
      that.logger.warn(err);
      that.close(null, err.message);
      return;
    }
    that.server.<span class="apidocCodeKeywordSpan">persistClient</span>(that);
    client.unsuback({
      messageId: packet.messageId
    });
  });
});

client.on(&#x22;disconnect&#x22;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.publish" id="apidoc.element.mosca.Server.prototype.publish">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>publish
        <span class="apidocSignatureSpan">(packet, client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(packet, client, callback) {

  var that = this;
  var logger = this.logger;

  if (typeof client === &#x27;function&#x27;) {
    callback = client;
    client = null;
  } else if (client) {
    logger = client.logger;
  }

  if (!callback) {
    callback = nop;
  }

  var newPacket = {
    topic: packet.topic,
    payload: packet.payload,
    messageId: this.generateUniqueId(),
    qos: packet.qos,
    retain: packet.retain
  };

  var opts = {
    qos: packet.qos,
    messageId: newPacket.messageId
  };

  if (client) {
    opts.clientId = client.id;
  }

  that.storePacket(newPacket, function() {
    if (that.closed) {
      logger.debug({ packet: newPacket }, &#x22;not delivering because we are closed&#x22;);
      return;
    }

    that.ascoltatore.publish(
      newPacket.topic,
      newPacket.payload,
      opts,
      function() {
        that.published(newPacket, client, function() {
          if( newPacket.topic.indexOf( &#x27;$SYS&#x27; ) &#x3e;= 0 ) {
            logger.trace({ packet: newPacket }, &#x22;published packet&#x22;);
          } else {
            logger.debug({ packet: newPacket }, &#x22;published packet&#x22;);
          }
          that.emit(&#x22;published&#x22;, newPacket, client);
          callback(undefined, newPacket);
        });
      }
    );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (!authorized) {
      that.logger.warn(packet, &#x22;Unauthorized Forward&#x22;);
      return;
    }

    that.connection.<span class="apidocCodeKeywordSpan">publish</span>(packet);

    if (packet.qos === 1) {
      that.inflight[packet.messageId] = packet;
    }
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.published" id="apidoc.element.mosca.Server.prototype.published">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>published
        <span class="apidocSignatureSpan">(packet, client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">published = function (packet, client, callback) {
  callback(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

that.ascoltatore.publish(
  newPacket.topic,
  newPacket.payload,
  opts,
  function() {
    that.<span class="apidocCodeKeywordSpan">published</span>(newPacket, client, function() {
      if( newPacket.topic.indexOf( &#x27;$SYS&#x27; ) &#x3e;= 0 ) {
        logger.trace({ packet: newPacket }, &#x22;published packet&#x22;);
      } else {
        logger.debug({ packet: newPacket }, &#x22;published packet&#x22;);
      }
      that.emit(&#x22;published&#x22;, newPacket, client);
      callback(undefined, newPacket);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.restoreClientSubscriptions" id="apidoc.element.mosca.Server.prototype.restoreClientSubscriptions">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>restoreClientSubscriptions
        <span class="apidocSignatureSpan">(client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restoreClientSubscriptions = function (client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._buildForward();

  client.on(&#x22;error&#x22;, nop);

  function completeConnection() {
that.setUpTimer();

that.server.<span class="apidocCodeKeywordSpan">restoreClientSubscriptions</span>(that, function(session_present) {
  client.connack({
    returnCode: 0,
    // maybe session_present is null, custom old persistence engine
    // or not persistence defined
    sessionPresent: session_present ? true : false
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.storePacket" id="apidoc.element.mosca.Server.prototype.storePacket">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>storePacket
        <span class="apidocSignatureSpan">(packet, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storePacket = function (packet, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
messageId: newPacket.messageId
  };

  if (client) {
opts.clientId = client.id;
  }

  that.<span class="apidocCodeKeywordSpan">storePacket</span>(newPacket, function() {
if (that.closed) {
  logger.debug({ packet: newPacket }, &#x22;not delivering because we are closed&#x22;);
  return;
}

that.ascoltatore.publish(
  newPacket.topic,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.subscribe" id="apidoc.element.mosca.Server.prototype.subscribe">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(topic, callback, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subscribe(topic, callback, done) {
  this.ascoltatore.subscribe(topic, callback, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var handler = function(topic, payload, options) {
  that.forward(topic, payload, options, s.topic, s.qos);
};

if (this.subscriptions[s.topic] === undefined) {
  this.subscriptions[s.topic] = { qos: s.qos, handler: handler };
  this.server.ascoltatore.<span class="apidocCodeKeywordSpan">subscribe</span>(
    s.topic,
    handler,
    function(err) {
      if (err) {
        delete that.subscriptions[s.topic];
        cb(err);
        return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.toString" id="apidoc.element.mosca.Server.prototype.toString">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return &#x27;mosca.Server&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

persistence: { factory: mosca.persistence.Redis, url: &#x27;localhost:6379&#x27;, ttl: { subscriptions: 1000 * 60 * 10, packets:
1000 * 60 * 10 } },

backend: pubsubSettings,
};

var authenticate = function (client, username, password, callback) {
if (username == &#x22;test&#x22; &#x26;&#x26; password.<span class="apidocCodeKeywordSpan">toString</span>() == &#x22;test&#x22;)
    callback(null, true);
else
    callback(null, false);
}

var authorizePublish = function (client, topic, payload, callback) {
callback(null, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.updateOfflinePacket" id="apidoc.element.mosca.Server.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, originMessageId, packet, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, originMessageId, packet, callback) {
  if (callback) {
    callback(null, packet);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &#x26;&#x26; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Stats" id="apidoc.module.mosca.Stats">module mosca.Stats</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Stats.Stats" id="apidoc.element.mosca.Stats.Stats">
        function <span class="apidocSignatureSpan">mosca.</span>Stats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats() {
  if (!(this instanceof Stats)) {
    return new Stats();
  }

  this.maxConnectedClients = 0;
  this.connectedClients = 0;
  this.lastIntervalConnectedClients = 0;
  this.publishedMessages = 0;
  this.lastIntervalPublishedMessages = 0;
  this.started = new Date();

  this.load = {
    m15: new Load(15),
    m5: new Load(5),
    m1: new Load(1)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var clock;
var interval = 10;

beforeEach(function() {
  clock = sinon.useFakeTimers();
  server = new EventEmitter();
  server.id = 42;
  instance = new mosca.<span class="apidocCodeKeywordSpan">Stats</span>();
  instance.wire(server);

  server.publish = function(packet) {
    server.emit(&#x22;testPublished&#x22;, packet);
  };
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Stats.prototype" id="apidoc.module.mosca.Stats.prototype">module mosca.Stats.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Stats.prototype.wire" id="apidoc.element.mosca.Stats.prototype.wire">
        function <span class="apidocSignatureSpan">mosca.Stats.prototype.</span>wire
        <span class="apidocSignatureSpan">(server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wire(server) {
  server.stats = this;

  var count = 0;

  function doPublish(topic, value) {
    server.publish({
      topic: &#x22;$SYS/&#x22; + server.id + &#x22;/&#x22; + topic,
      payload: &#x22;&#x22; + value
    });
  }

  var mom = moment(this.started);

  var timer = setInterval(function() {
    var stats = server.stats;
    var mem = process.memoryUsage();

    var date = new Date();

    stats.load.m1.maConnectedClients.push(date, stats.lastIntervalConnectedClients);
    stats.load.m5.maConnectedClients.push(date, stats.lastIntervalConnectedClients);
    stats.load.m15.maConnectedClients.push(date, stats.lastIntervalConnectedClients);
    stats.lastIntervalConnectedClients = 0;

    stats.load.m1.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);
    stats.load.m5.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);
    stats.load.m15.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);
    stats.lastIntervalPublishedMessages = 0;

    doPublish(&#x22;version&#x22;, version);
    doPublish(&#x22;started_at&#x22;, server.stats.started.toISOString());
    doPublish(&#x22;uptime&#x22;, mom.from(Date.now(), true));
    doPublish(&#x22;clients/maximum&#x22;, stats.maxConnectedClients);
    doPublish(&#x22;clients/connected&#x22;, stats.connectedClients);
    doPublish(&#x22;publish/received&#x22;, stats.publishedMessages);
    doPublish(&#x22;load/connections/15min&#x22;, stats.load.m15.connectedClients);
    doPublish(&#x22;load/publish/received/15min&#x22;, stats.load.m15.publishedMessages);
    doPublish(&#x22;load/connections/5min&#x22;, stats.load.m5.connectedClients);
    doPublish(&#x22;load/publish/received/5min&#x22;, stats.load.m5.publishedMessages);
    doPublish(&#x22;load/connections/1min&#x22;, stats.load.m1.connectedClients);
    doPublish(&#x22;load/publish/received/1min&#x22;, stats.load.m1.publishedMessages);
    doPublish(&#x22;memory/rss&#x22;, mem.rss);
    doPublish(&#x22;memory/heap/current&#x22;, mem.heapUsed);
    doPublish(&#x22;memory/heap/maximum&#x22;, mem.heapTotal);
  }, 10 * 1000);

  events.forEach(function(event) {
    server.on(event.name, event);
  });

  server.once(&#x22;closed&#x22;, function() {
    clearInterval(timer);

    events.forEach(function(event) {
      server.removeListener(event.name, event);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  delete this.modernOpts.logger.name;
  this.logger = this.logger.child(this.modernOpts.logger);
} else {
  this.logger = pino(this.modernOpts.logger);
}

if(this.modernOpts.stats) {
  new Stats().<span class="apidocCodeKeywordSpan">wire</span>(this);
}

var that = this;

// each Server has a dummy id for logging purposes
this.id = this.modernOpts.id || shortid.generate();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.abstract" id="apidoc.module.mosca.abstract">module mosca.abstract</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.abstract.abstract" id="apidoc.element.mosca.abstract.abstract">
        function <span class="apidocSignatureSpan">mosca.</span>abstract
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.abstract.super_" id="apidoc.element.mosca.abstract.super_">
        function <span class="apidocSignatureSpan">mosca.abstract.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.client" id="apidoc.module.mosca.client">module mosca.client</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.client.client" id="apidoc.element.mosca.client.client">
        function <span class="apidocSignatureSpan">mosca.</span>client
        <span class="apidocSignatureSpan">(conn, server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(conn, server) {
  this.connection = conn;
  this.server = server;
  this.logger = server.logger;
  this.subscriptions = {};

  this.nextId = 1;
  this.inflight = {};
  this.inflightCounter = 0;
  this._lastDedupId = -1;
  this._closed = false;
  this._closing = false;

  this._setup();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.client.prototype" id="apidoc.module.mosca.client.prototype">module mosca.client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.client.prototype._buildForward" id="apidoc.element.mosca.client.prototype._buildForward">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_buildForward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_buildForward = function () {
  var that = this;

  function doForward(err, packet) {
    if (err) {
      return that.client &#x26;&#x26; that.client.emit(&#x27;error&#x27;, err);
    }

    that.server.authorizeForward(that, packet, function(err, authorized) {
      if (err) {
        return that.client &#x26;&#x26; that.client.emit(&#x27;error&#x27;, err);
      }

      if (!authorized) {
        that.logger.warn(packet, &#x22;Unauthorized Forward&#x22;);
        return;
      }

      that.connection.publish(packet);

      if (packet.qos === 1) {
        that.inflight[packet.messageId] = packet;
      }
    });
  }

  this.forward = function(topic, payload, options, subTopic, qos, cb) {
    if (options._dedupId &#x3c;= that._lastDedupId) {
      return;
    }

    that.logger.trace({ topic: topic }, &#x22;delivering message&#x22;);

    var sub = that.subscriptions[subTopic],
        indexWildcard = subTopic.indexOf(&#x22;#&#x22;),
        indexPlus = subTopic.indexOf(&#x22;+&#x22;),
        forward = true,
        newId = this.nextId++;

    // Make sure &#x27;nextId&#x27; always fits in a uint8 (http://git.io/vmgKI).
    this.nextId %= 65536;

    var packet = {
      topic: topic,
      payload: payload,
      qos: qos,
      messageId: newId
    };

    if (qos) {
      that.inflightCounter++;
    }

    if (that._closed || that._closing) {
      that.logger.debug({ packet: packet }, &#x22;trying to send a packet to a disconnected client&#x22;);
      forward = false;
    } else if (that.inflightCounter &#x3e;= that.server.opts.maxInflightMessages) {
      that.logger.warn(&#x22;too many inflight packets, closing&#x22;);
      that.close(null, &#x22;too many inflight packets&#x22;);
      forward = false;
    }

    if (cb) {
      cb();
    }

    // skip delivery of messages in $SYS for wildcards
    forward = forward &#x26;&#x26;
              ! ( topic.indexOf(&#x27;$SYS&#x27;) &#x3e;= 0 &#x26;&#x26;
                  (
                    indexWildcard &#x3e;= 0 &#x26;&#x26;
                    indexWildcard &#x3c; 2 ||
                    indexPlus &#x3e;= 0 &#x26;&#x26;
                    indexPlus &#x3c; 2
                  )
                );

    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &#x26;&#x26; options.messageId) {
        that.server.updateOfflinePacket(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up all the handlers, to not be called directly.
 *
 * @api private
 */
Client.prototype._setup = function() {
  var that = this, client = that.connection;

  this.<span class="apidocCodeKeywordSpan">_buildForward</span>();

  client.on(&#x22;error&#x22;, nop);

  function completeConnection() {
that.setUpTimer();

that.server.restoreClientSubscriptions(that, function(session_present) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype._setup" id="apidoc.element.mosca.client.prototype._setup">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setup = function () {
  var that = this, client = that.connection;

  this._buildForward();

  client.on(&#x22;error&#x22;, nop);

  function completeConnection() {
    that.setUpTimer();

    that.server.restoreClientSubscriptions(that, function(session_present) {
      client.connack({
        returnCode: 0,
        // maybe session_present is null, custom old persistence engine
        // or not persistence defined
        sessionPresent: session_present ? true : false
      });

      that.logger.info(&#x22;client connected&#x22;);
      that.server.emit(&#x22;clientConnected&#x22;, that);

      // packets will be forward only if client.clean is false
      that.server.forwardOfflinePackets(that);
    });

    client.on(&#x22;puback&#x22;, function(packet) {
      that.setUpTimer();
      that.handlePuback(packet);
    });

    client.on(&#x22;pingreq&#x22;, function() {
      that.logger.debug(&#x22;pingreq&#x22;);
      that.setUpTimer();
      that.handlePingreq();
      that.connection.pingresp();
    });

    client.on(&#x22;subscribe&#x22;, function(packet) {
      that.setUpTimer();
      that.handleSubscribe(packet);
    });

    client.on(&#x22;publish&#x22;, function(packet) {
      that.setUpTimer();
      that.server.authorizePublish(that, packet.topic, packet.payload, function(err, success) {
        that.handleAuthorizePublish(err, success, packet);
      });
    });

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
      that.setUpTimer();
      that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
      steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
        if (err) {
          that.logger.warn(err);
          that.close(null, err.message);
          return;
        }
        that.server.persistClient(that);
        client.unsuback({
          messageId: packet.messageId
        });
      });
    });

    client.on(&#x22;disconnect&#x22;, function() {
      that.logger.debug(&#x22;disconnect requested&#x22;);
      that.close(null, &#x22;disconnect request&#x22;);
    });

    function handleError(err) {
      that.logger.warn(err);
      that.onNonDisconnectClose(err.message);
    }

    client.on(&#x22;error&#x22;, handleError);
    client.removeListener(&#x22;error&#x22;, nop);

    client.on(&#x22;close&#x22;, function() {
      that.onNonDisconnectClose(&#x22;close&#x22;);
    });
  }

  client.once(&#x22;connect&#x22;, function(packet) {
    that.handleConnect(packet, completeConnection);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.nextId = 1;
 this.inflight = {};
 this.inflightCounter = 0;
 this._lastDedupId = -1;
 this._closed = false;
 this._closing = false;

 this.<span class="apidocCodeKeywordSpan">_setup</span>();
}

/**
* Sets up all the handlers, to not be called directly.
*
* @api private
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.close" id="apidoc.element.mosca.client.prototype.close">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>close
        <span class="apidocSignatureSpan">(callback, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback, reason) {

  callback = callback || nop;

  if (this._closed || this._closing) {
    return callback();
  }

  var that = this;

  if (this.id) {
    that.logger.debug(&#x22;closing client, reason: &#x22; + reason);

    if (this.timer) {
      this.timer.clear();
    }
  }

  var cleanup = function() {
    that._closed = true;

    that.logger.info(&#x22;closed&#x22;);
    that.connection.removeAllListeners();
    // ignore all errors after disconnection
    that.connection.on(&#x22;error&#x22;, function() {});
    that.server.emit(&#x22;clientDisconnected&#x22;, that, reason);

    callback();
  };

  that._closing = true;

  steed.map(that, Object.keys(that.subscriptions), that.unsubscribeMapTo, function(err) {
    if (err) {
      that.logger.info(err);
    }

    // needed in case of errors
    if (!that._closed) {
      cleanup();
      // prefer destroy[Soon]() to prevent FIN_WAIT zombie connections
      if (that.connection.stream.destroySoon) {
        that.connection.stream.destroySoon();
      } else if (that.connection.stream.destroy) {
        that.connection.stream.destroy();
      } else {
        that.connection.stream.end();
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleAuthorizePublish" id="apidoc.element.mosca.client.prototype.handleAuthorizePublish">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizePublish
        <span class="apidocSignatureSpan">(err, success, packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleAuthorizePublish = function (err, success, packet) {
  var that = this;

  if (err || !success) {
    if (!this._closed &#x26;&#x26; !this._closing) {
      that.close(null, (err &#x26;&#x26; err.message) || &#x22;publish not authorized&#x22;);
    }
    return;
  }

  if (success instanceof Buffer) {
    packet.payload = success;
  }

  that.server.publish(packet, that, function() {
    if (packet.qos === 1 &#x26;&#x26; !(that._closed || that._closing)) {
      that.connection.puback({
        messageId: packet.messageId
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.setUpTimer();
  that.handleSubscribe(packet);
});

client.on(&#x22;publish&#x22;, function(packet) {
  that.setUpTimer();
  that.server.authorizePublish(that, packet.topic, packet.payload, function(err, success) {
    that.<span class="apidocCodeKeywordSpan">handleAuthorizePublish</span>(err, success, packet);
  });
});

client.on(&#x22;unsubscribe&#x22;, function(packet) {
  that.setUpTimer();
  that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
  steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleAuthorizeSubscribe" id="apidoc.element.mosca.client.prototype.handleAuthorizeSubscribe">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizeSubscribe
        <span class="apidocSignatureSpan">(err, success, s, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleAuthorizeSubscribe = function (err, success, s, cb) {
  if (err) {
    cb(err);
    return;
  }

  if (!success) {
    this.logger.info({ topic: s.topic }, &#x22;subscribe not authorized&#x22;);
    cb(null, false);
    return;
  }

  var that = this;

  var handler = function(topic, payload, options) {
    that.forward(topic, payload, options, s.topic, s.qos);
  };

  if (this.subscriptions[s.topic] === undefined) {
    this.subscriptions[s.topic] = { qos: s.qos, handler: handler };
    this.server.ascoltatore.subscribe(
      s.topic,
      handler,
      function(err) {
        if (err) {
          delete that.subscriptions[s.topic];
          cb(err);
          return;
        }
        that.logger.info({ topic: s.topic, qos: s.qos }, &#x22;subscribed to topic&#x22;);
        //that.subscriptions[s.topic] = { qos: s.qos, handler: handler };
        cb(null, true);
      }
    );
  } else {
    cb(null, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

function handleEachSub (s, cb) {
  /*jshint validthis:true */
  var that = this;
  if (this.subscriptions[s.topic] === undefined) {
    this.server.authorizeSubscribe(that, s.topic, function(err, success) {
      that.<span class="apidocCodeKeywordSpan">handleAuthorizeSubscribe</span>(err, success, s, cb);
    });
  } else {
    cb(null, true);
  }
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleConnect" id="apidoc.element.mosca.client.prototype.handleConnect">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleConnect
        <span class="apidocSignatureSpan">(packet, completeConnection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleConnect = function (packet, completeConnection) {
  var that = this, logger, client = this.connection;

  this.id = packet.clientId;

  this.logger = logger = that.logger.child({ client: this });

  // for MQTT 3.1.1 (protocolVersion == 4) it is valid to receive an empty
  // clientId if cleanSession is set to 1. In this case, Mosca should generate
  // a random ID.
  // Otherwise, the connection should be rejected.
  if(!this.id) {

    if(packet.protocolVersion == 4 &#x26;&#x26; packet.clean) {

      this.id = uuid.v4();
    }
    else {

      logger.info(&#x22;identifier rejected&#x22;);
      client.connack({
        returnCode: 2
      });
      client.stream.end();
      return;
    }
  }


  that.server.authenticate(this, packet.username, packet.password,
                           function(err, verdict) {

    if (err) {
      logger.info({ username: packet.username }, &#x22;authentication error&#x22;);
      client.connack({
        returnCode: 4
      });
      client.stream.end();
      return;
    }

    if (!verdict) {
      logger.info({ username: packet.username }, &#x22;authentication denied&#x22;);
      client.connack({
        returnCode: 5
      });
      client.stream.end();
      return;
    }

    that.keepalive = packet.keepalive;
    that.will = packet.will;

    that.clean = packet.clean;

    if (that.id in that.server.clients){
      that.server.clients[that.id].close(completeConnection, &#x22;new connection request&#x22;);
    } else {
      completeConnection();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   client.on(&#x22;close&#x22;, function() {
     that.onNonDisconnectClose(&#x22;close&#x22;);
   });
 }

 client.once(&#x22;connect&#x22;, function(packet) {
   that.<span class="apidocCodeKeywordSpan">handleConnect</span>(packet, completeConnection);
 });
};

/**
* Sets up the keepalive timer.
* To not be called directly.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handlePingreq" id="apidoc.element.mosca.client.prototype.handlePingreq">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePingreq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handlePingreq = function () {
  var that = this;
  that.server.emit(&#x22;pingreq&#x22;, that);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.setUpTimer();
  that.handlePuback(packet);
});

client.on(&#x22;pingreq&#x22;, function() {
  that.logger.debug(&#x22;pingreq&#x22;);
  that.setUpTimer();
  that.<span class="apidocCodeKeywordSpan">handlePingreq</span>();
  that.connection.pingresp();
});

client.on(&#x22;subscribe&#x22;, function(packet) {
  that.setUpTimer();
  that.handleSubscribe(packet);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handlePuback" id="apidoc.element.mosca.client.prototype.handlePuback">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePuback
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handlePuback = function (packet) {
  var logger = this.logger;
  var that = this;

  logger.debug({ packet: packet }, &#x22;puback&#x22;);
  if (this.inflight[packet.messageId]) {
    this.server.emit(&#x22;delivered&#x22;, this.inflight[packet.messageId], that);
    this.inflightCounter--;
    delete this.inflight[packet.messageId];
    this.server.deleteOfflinePacket(this, packet.messageId, function(err) {
      if (err) {
        return that.client &#x26;&#x26; that.client.emit(&#x22;error&#x22;, err);
      }
      logger.debug({ packet: packet }, &#x22;cleaned offline packet&#x22;);
    });
  } else {
    logger.info({ packet: packet }, &#x22;no matching packet&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // packets will be forward only if client.clean is false
  that.server.forwardOfflinePackets(that);
});

client.on(&#x22;puback&#x22;, function(packet) {
  that.setUpTimer();
  that.<span class="apidocCodeKeywordSpan">handlePuback</span>(packet);
});

client.on(&#x22;pingreq&#x22;, function() {
  that.logger.debug(&#x22;pingreq&#x22;);
  that.setUpTimer();
  that.handlePingreq();
  that.connection.pingresp();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleSubscribe" id="apidoc.element.mosca.client.prototype.handleSubscribe">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleSubscribe
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSubscribe = function (packet) {
  var that = this, server = this.server, logger = this.logger;

  logger.debug({ packet: packet }, &#x22;subscribe received&#x22;);

  var granted = calculateGranted(this, packet);

  steed.map(this, packet.subscriptions, handleEachSub, function(err, authorized) {

    if (err) {
      that.close(null, err.message);
      return;
    }

    that.server.persistClient(that);

    packet.subscriptions.forEach(function(sub, index) {
      if (authorized[index]) {
        that.server.forwardRetained(sub.topic, that);
        that.server.emit(&#x22;subscribed&#x22;, sub.topic, that);
      } else {
        granted[index] = 0x80;
      }
    });

    if(!that._closed) {
      that.connection.suback({
        messageId: packet.messageId,
        granted: granted
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.setUpTimer();
  that.handlePingreq();
  that.connection.pingresp();
});

client.on(&#x22;subscribe&#x22;, function(packet) {
  that.setUpTimer();
  that.<span class="apidocCodeKeywordSpan">handleSubscribe</span>(packet);
});

client.on(&#x22;publish&#x22;, function(packet) {
  that.setUpTimer();
  that.server.authorizePublish(that, packet.topic, packet.payload, function(err, success) {
    that.handleAuthorizePublish(err, success, packet);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.onNonDisconnectClose" id="apidoc.element.mosca.client.prototype.onNonDisconnectClose">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>onNonDisconnectClose
        <span class="apidocSignatureSpan">(reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNonDisconnectClose = function (reason) {
  var that = this, logger = that.logger, will = that.will;

  if (this._closed || this._closing) {
    return;
  }

  if (that.will) {
    logger.info({ packet: will }, &#x22;delivering last will&#x22;);
    setImmediate(function() {
      that.server.authorizePublish(that, will.topic, will.payload, function(err, success) {
        that.handleAuthorizePublish(err, success, will);
      });
    });
  }

  this.close(null, reason);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
client.on(&#x22;disconnect&#x22;, function() {
  that.logger.debug(&#x22;disconnect requested&#x22;);
  that.close(null, &#x22;disconnect request&#x22;);
});

function handleError(err) {
  that.logger.warn(err);
  that.<span class="apidocCodeKeywordSpan">onNonDisconnectClose</span>(err.message);
}

client.on(&#x22;error&#x22;, handleError);
client.removeListener(&#x22;error&#x22;, nop);

client.on(&#x22;close&#x22;, function() {
  that.onNonDisconnectClose(&#x22;close&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.setUpTimer" id="apidoc.element.mosca.client.prototype.setUpTimer">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>setUpTimer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setUpTimer = function () {
  if (this.keepalive &#x3c;= 0) {
    return;
  }

  var timeout = this.keepalive * 1000 * 3 / 2;
  var that = this;

  this.logger.debug({ timeout: timeout }, &#x22;setting keepalive timeout&#x22;);

  if (this.timer) {
    this.timer.reschedule(timeout);
  } else {
    this.timer = retimer(function keepaliveTimeout() {
      that.logger.info(&#x22;keepalive timeout&#x22;);
      that.onNonDisconnectClose(&#x22;keepalive timeout&#x22;);
    }, timeout);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var that = this, client = that.connection;

  this._buildForward();

  client.on(&#x22;error&#x22;, nop);

  function completeConnection() {
that.<span class="apidocCodeKeywordSpan">setUpTimer</span>();

that.server.restoreClientSubscriptions(that, function(session_present) {
  client.connack({
    returnCode: 0,
    // maybe session_present is null, custom old persistence engine
    // or not persistence defined
    sessionPresent: session_present ? true : false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.unsubscribeMapTo" id="apidoc.element.mosca.client.prototype.unsubscribeMapTo">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>unsubscribeMapTo
        <span class="apidocSignatureSpan">(topic, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribeMapTo = function (topic, cb) {
  var that = this;
  var sub = that.subscriptions[topic];
  if (!sub || !sub.handler) {
    that.server.emit(&#x22;unsubscribed&#x22;, topic, that);
    return cb();
  }

  that.server.ascoltatore.unsubscribe(topic, sub.handler, function(err) {
    if (err) {
      cb(err);
      return;
    }

    if (!that._closing || that.clean) {
      delete that.subscriptions[topic];
      that.logger.info({ topic: topic }, &#x22;unsubscribed&#x22;);
      that.server.emit(&#x22;unsubscribed&#x22;, topic, that);
    }

    cb();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.interfaces" id="apidoc.module.mosca.interfaces">module mosca.interfaces</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.interfaces.buildServe" id="apidoc.element.mosca.interfaces.buildServe">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildServe
        <span class="apidocSignatureSpan">(iface, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildServe(iface, mosca) {
  var mounts = [];
  var logger = mosca.logger.child({ service: &#x27;http bundle&#x27; });

  if (iface.bundle) {
    mounts.push(st({
      path: __dirname + &#x22;/../public&#x22;,
      url: &#x22;/&#x22;,
      dot: true,
      index: false,
      passthrough: true
    }));
  }

  if (iface.static) {
    mounts.push(st({
      path: iface.static,
      dot: true,
      url: &#x22;/&#x22;,
      index: &#x22;index.html&#x22;,
      passthrough: true
    }));
  }

  return function serve(req, res) {

    logger.info({ req: req });

    var cmounts = [].concat(mounts);

    res.on(&#x27;finish&#x27;, function() {
      logger.info({ res: res });
    });

    function handle() {
      var mount = cmounts.shift();

      if (mount) {
        mount(req, res, handle);
      } else {
        res.statusCode = 404;
        res.end(&#x22;Not Found\n&#x22;);
      }
    }

    handle();
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.buildWrap" id="apidoc.element.mosca.interfaces.buildWrap">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildWrap
        <span class="apidocSignatureSpan">(mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildWrap(mosca) {
  return function wrap(stream) {
    var connection = new Connection(stream);
    stream.setNoDelay(true);
    new Client(connection, mosca); // REFACTOR?
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.httpFactory" id="apidoc.element.mosca.interfaces.httpFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function httpFactory(iface, fallback, mosca) {
  var serve = buildServe(iface, mosca);
  var server = http.createServer(serve);

  mosca.attachHttpServer(server);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.httpsFactory" id="apidoc.element.mosca.interfaces.httpsFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpsFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function httpsFactory(iface, fallback, mosca) {
  var credentials = iface.credentials || fallback.credentials;
  if (credentials === undefined) {
    throw new Error(&#x22;missing credentials for https server&#x22;);
  }

  if (credentials.keyPath) {
    credentials.key = fs.readFileSync(credentials.keyPath);
  }

  if (credentials.certPath) {
    credentials.cert = fs.readFileSync(credentials.certPath);
  }

  if (credentials.caPaths) {
    credentials.ca = [];
    credentials.caPaths.forEach(function (caPath) {
    	credentials.ca.push(fs.readFileSync(caPath));
    });
  }

  var serve = buildServe(iface, mosca);
  var server = https.createServer(credentials, serve);
  mosca.attachHttpServer(server);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.mqttFactory" id="apidoc.element.mosca.interfaces.mqttFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mqttFactory(iface, fallback, mosca) {
  return net.createServer(buildWrap(mosca));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.mqttsFactory" id="apidoc.element.mosca.interfaces.mqttsFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttsFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mqttsFactory(iface, fallback, mosca) {
  var credentials = iface.credentials || fallback.credentials;
  if (credentials === undefined) {
    throw new Error(&#x22;missing credentials for mqtts server&#x22;);
  }

  if (credentials.keyPath) {
    credentials.key = fs.readFileSync(credentials.keyPath);
  }

  if (credentials.certPath) {
    credentials.cert = fs.readFileSync(credentials.certPath);
  }

  if (credentials.caPaths) {
    credentials.ca = [];
    credentials.caPaths.forEach(function (caPath) {
    	credentials.ca.push(fs.readFileSync(caPath));
    });
  }

  return tls.createServer(credentials, buildWrap(mosca));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.serverFactory" id="apidoc.element.mosca.interfaces.serverFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>serverFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serverFactory(iface, fallback, mosca) {
  var factories = {
    &#x22;mqtt&#x22;:  mqttFactory,
    &#x22;mqtts&#x22;: mqttsFactory,
    &#x22;http&#x22;:  httpFactory,
    &#x22;https&#x22;: httpsFactory,
  };

  var type = iface.type; // no fallback
  var factory = factories[type] || type;
  return factory(iface, fallback, mosca);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function (done) {

  steed.eachSeries(that.modernOpts.interfaces, function (iface, dn) {
    var fallback = that.modernOpts;
    var host = iface.host || that.modernOpts.host;
    var port = iface.port || that.modernOpts.port;

    var server = interfaces.<span class="apidocCodeKeywordSpan">serverFactory</span>(iface, fallback, that);
    that.servers.push(server);
    server.maxConnections = iface.maxConnections || 10000000;
    server.listen(port, host, dn);
  }, done);
},

// steed.series: log startup information
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.matcher" id="apidoc.module.mosca.matcher">module mosca.matcher</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.matcher.matcher" id="apidoc.element.mosca.matcher.matcher">
        function <span class="apidocSignatureSpan">mosca.</span>matcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matcher() {
  Qlobber.call(this, { separator: &#x22;/&#x22;, wildcard_one: &#x22;+&#x22; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.matcher.super_" id="apidoc.element.mosca.matcher.super_">
        function <span class="apidocSignatureSpan">mosca.matcher.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QlobberDedup(options)
{
    Qlobber.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.options" id="apidoc.module.mosca.options">module mosca.options</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.options.defaultsLegacy" id="apidoc.element.mosca.options.defaultsLegacy">
        function <span class="apidocSignatureSpan">mosca.options.</span>defaultsLegacy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultsLegacy() {
  return {
    port: 1883,
    host: null,
    maxConnections: 10000000,
    backend: {
      json: false,
      wildcardOne: &#x27;+&#x27;,
      wildcardSome: &#x27;#&#x27;
    },
    stats: false,
    publishNewClient: true,
    publishClientDisconnect: true,
    publishSubscriptions: true,
    maxInflightMessages: 1024,
    logger: {
      name: &#x22;mosca&#x22;,
      level: &#x22;warn&#x22;,
      serializers: {
        client: serializers.clientSerializer,
        packet: serializers.packetSerializer,
        req: pino.stdSerializers.req,
        res: pino.stdSerializers.res
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Client = require(&#x22;./client&#x22;);
var Stats = require(&#x22;./stats&#x22;);
var shortid = require(&#x22;shortid&#x22;);
var persistence = require(&#x27;./persistence&#x27;);
var options = require(&#x27;./options&#x27;);
var interfaces = require(&#x27;./interfaces&#x27;);

var defaults = options.<span class="apidocCodeKeywordSpan">defaultsLegacy</span>();
var nop = function() {};

/**
* The Mosca Server is a very simple MQTT server that
* provides a simple event-based API to craft your own MQTT logic
* It supports QoS 0 &#x26; 1, without external storage.
* It is backed by Ascoltatori, and it descends from
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.defaultsModern" id="apidoc.element.mosca.options.defaultsModern">
        function <span class="apidocSignatureSpan">mosca.options.</span>defaultsModern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultsModern() {
  return {
    host: null,
    interfaces: [
      { type: &#x22;mqtt&#x22;, port: 1883, maxConnections: 10000000 }
    ],
    backend: {
      json: false,
      wildcardOne: &#x27;+&#x27;,
      wildcardSome: &#x27;#&#x27;
    },
    stats: false,
    publishNewClient: true,
    publishClientDisconnect: true,
    publishSubscriptions: true,
    maxInflightMessages: 1024,
    logger: {
      name: &#x22;mosca&#x22;,
      level: &#x22;warn&#x22;,
      serializers: {
        client: serializers.clientSerializer,
        packet: serializers.packetSerializer,
        req: pino.stdSerializers.req,
        res: pino.stdSerializers.res
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

describe(&#x22;mocha.options&#x22;, function () {

  describe(&#x22;modern defaults&#x22;, function () {

it(&#x22;should not contain legacy keys&#x22;, function () {
  var modern = options.<span class="apidocCodeKeywordSpan">defaultsModern</span>();

  legacyKeys.forEach(function (key) {
    expect(modern).to.not.have.property(key);
  });
});

it(&#x22;should contain fallback host&#x22;, function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.modernize" id="apidoc.element.mosca.options.modernize">
        function <span class="apidocSignatureSpan">mosca.options.</span>modernize
        <span class="apidocSignatureSpan">(legacy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modernize(legacy) {

  legacy = legacy || {};

  var modernized = {};

  // &#x22;plain copyable&#x22; conserved options
  var conserved = [
    &#x22;id&#x22;,
    &#x22;host&#x22;,
    &#x22;maxInflightMessages&#x22;,
    &#x22;stats&#x22;,
    &#x22;publishNewClient&#x22;,
    &#x22;publishClientDisconnect&#x22;,
    &#x22;publishSubscriptions&#x22;
  ];

  // copy all conserved options
  conserved.forEach(function (name) {
    if (legacy.hasOwnProperty(name)) {
      modernized[name] = legacy[name];
    }
  });

  // TODO: copy `backend` carefully
  if (legacy.hasOwnProperty(&#x27;backend&#x27;)) {
    modernized.backend = legacy.backend;
  }

  // TODO: copy `ascoltatore` carefully
  if (legacy.hasOwnProperty(&#x27;ascoltatore&#x27;)) {
    modernized.ascoltatore = legacy.ascoltatore;
  }

  // TODO: copy `persistence` carefully
  if (legacy.hasOwnProperty(&#x27;persistence&#x27;)) {
    modernized.persistence = legacy.persistence;
  }

  // TODO: copy `logger` carefully
  if (legacy.hasOwnProperty(&#x27;logger&#x27;)) {
    modernized.logger = legacy.logger;
  }

  // construct `credentials`
  if (legacy.hasOwnProperty(&#x27;credentials&#x27;)) {
    // copy as is
    modernized.credentials = clone(legacy.credentials);
  } else if (legacy.hasOwnProperty(&#x27;secure&#x27;)) {
    // construct from `secure`
    modernized.credentials = {};
    if (legacy.secure.hasOwnProperty(&#x27;keyPath&#x27;)) {
      modernized.credentials.keyPath = legacy.secure.keyPath;
    }
    if (legacy.secure.hasOwnProperty(&#x27;certPath&#x27;)) {
      modernized.credentials.certPath = legacy.secure.certPath;
    }
  } // else no credentials were provided

  // construct `interfaces`
  if (legacy.hasOwnProperty(&#x27;interfaces&#x27;)) {
    // cloning
    modernized.interfaces = clone(legacy.interfaces);
  } else {
    // construct from legacy keys
    modernized.interfaces = [];

    // translate mqtt options
    var mqtt_enabled = !legacy.onlyHttp &#x26;&#x26; (typeof legacy.secure === &#x27;undefined&#x27; || legacy.allowNonSecure);
    if (mqtt_enabled) {
      var mqtt_interface = { type: &#x27;mqtt&#x27; };

      if (legacy.hasOwnProperty(&#x27;port&#x27;)) {
        mqtt_interface.port = legacy.port;
      }

      if (legacy.hasOwnProperty(&#x27;maxConnections&#x27;)) {
        mqtt_interface.maxConnections = legacy.maxConnections;
      }

      modernized.interfaces.push(mqtt_interface);
    }

    // translate mqtts options
    var mqtts_enabled = !legacy.onlyHttp &#x26;&#x26; legacy.secure;
    if (mqtts_enabled) {
      var mqtts_interface = { type: &#x27;mqtts&#x27; };

      if (legacy.secure.hasOwnProperty(&#x27;port&#x27;)) {
        mqtts_interface.port = legacy.secure.port;
      }

      modernized.interfaces.push(mqtts_interface);
    }

    // translate http options
    var http_enabled = !!(legacy.http);
    if (http_enabled) {
      var http_interface = { type: &#x27;http&#x27; };

      if (legacy.http.hasOwnProperty(&#x27;port&#x27;)) {
        http_interface.port = legacy.http.port;
      }

      if (legacy.http.hasOwnProperty(&#x27;bundle&#x27;)) {
        http_interface.bundle = legacy.http.bundle;
      }

      if (legacy.http.hasOwnProperty(&#x27;static&#x27;)) {
        http_interface.static = legacy.http.static;
      }

      modernized.interfaces.push(http_interface);
    }

    // translate https options
    var https_enabled = !!(legacy.https);
    if (https_enabled) {
      var https_interface = { type: &#x27;https&#x27; };

      if (legacy.https.hasOwnProperty(&#x27;port&#x27;)) {
        https_interface.port = legacy.https.port;
      }

      if (legacy.https.hasOwnProperty(&#x27;bundle&#x27;)) {
        https_interface.bundle = legacy.https.bundle;
      }

      if (legacy.https.hasOwnProperty(&#x27;static&#x27;)) {
        https_interface.static = legacy.https.static;
      }

      modernized.interfaces.push(https_interface);
    }

    // NOTE: there are ways end up with no interfaces at all, for example
    // `httpOnly: true` with undefined http and https
  }

  return modernized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *    the topic and the client are passed as parameters.
 *
 * @param {Object} opts The option object
 * @param {Function} callback The ready callback
 * @api public
 */
function Server(opts, callback) {
var modernOpts = options.<span class="apidocCodeKeywordSpan">modernize</span>(opts);
var validationResult = options.validate(modernOpts);

if (validationResult.errors.length &#x3e; 0) {
  var errMessage = validationResult.errors[0].message;
  if (callback) {
    callback(new Error(errMessage));
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.populate" id="apidoc.element.mosca.options.populate">
        function <span class="apidocSignatureSpan">mosca.options.</span>populate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function populate(opts) {
  var defaults = defaultsModern();

  // do not extend `interfaces`
  if (opts.hasOwnProperty(&#x27;interfaces&#x27;)) {
    delete defaults.interfaces;
  }
  var populated = extend(true, defaults, opts);

  populated.interfaces.forEach(function (iface) {
    if (typeof iface.port === &#x22;undefined&#x22;) {
      switch (iface.type) {
        case &#x22;mqtt&#x22;:   iface.port = 1883; break;
        case &#x22;mqtts&#x22;:  iface.port = 8883; break;
        case &#x22;http&#x22;:   iface.port = 3000; break;
        case &#x22;https&#x22;:  iface.port = 3001; break;
      }
    }
  });

  return populated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (callback) {
    callback(new Error(errMessage));
  } else {
    throw new Error(errMessage);
  }
}

modernOpts = options.<span class="apidocCodeKeywordSpan">populate</span>(modernOpts);

if (!(this instanceof Server)) {
  return new Server(opts, callback);
}

EventEmitter.call(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.validate" id="apidoc.element.mosca.options.validate">
        function <span class="apidocSignatureSpan">mosca.options.</span>validate
        <span class="apidocSignatureSpan">(opts, validationOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(opts, validationOptions) {
  var validator = new jsonschema.Validator();

  // custom function type
  validator.types.function = function testFunction(instance) {
    return instance instanceof Function;
  };

  validator.addSchema({
    id: &#x27;/Credentials&#x27;,
    type: &#x27;object&#x27;,
    additionalProperties: true,
    properties: {
      &#x27;keyPath&#x27;: { type: &#x27;string&#x27;, required: true },
      &#x27;certPath&#x27;: { type: &#x27;string&#x27;, required: true },
      &#x27;caPaths&#x27;: { type: &#x27;array&#x27;, required: false },
      &#x27;requestCert&#x27;: { type: &#x27;boolean&#x27;, required: false },
      &#x27;rejectUnauthorized&#x27;: { type: &#x27;boolean&#x27;, required: false }
    }
  });

  validator.addSchema({
    id: &#x27;/Interface&#x27;,
    type: &#x27;object&#x27;,
    properties: {
      &#x27;type&#x27;: { type: [&#x27;string&#x27;, &#x27;function&#x27;], required: true },
      &#x27;host&#x27;: { type: [&#x27;string&#x27;, &#x27;null&#x27;] },
      &#x27;port&#x27;: { type: [&#x27;integer&#x27;] },
      &#x27;credentials&#x27;: { $ref: &#x27;/Credentials&#x27; },
    }
  });

  validator.addSchema({
    id: &#x27;/Options&#x27;,
    type: &#x27;object&#x27;,
    additionalProperties: false,
    properties: {
      &#x27;id&#x27;: { type: &#x27;string&#x27; },
      &#x27;host&#x27;: { type: [&#x27;string&#x27;, &#x27;null&#x27;] },
      &#x27;interfaces&#x27;: {
        type: &#x27;array&#x27;,
        items: { $ref: &#x27;/Interface&#x27; }
      },
      &#x27;credentials&#x27;: { $ref: &#x27;/Credentials&#x27; },

      &#x27;backend&#x27;: { type: &#x27;object&#x27; },     // TODO
      &#x27;ascoltatore&#x27;: { type: &#x27;object&#x27; }, // TODO
      &#x27;persistence&#x27;: { type: &#x27;object&#x27; }, // TODO
      &#x27;logger&#x27;: { type: &#x27;object&#x27; },      // TODO

      &#x27;maxInflightMessages&#x27;: { type: &#x27;integer&#x27; },
      &#x27;stats&#x27;: { type: &#x27;boolean&#x27; },
      &#x27;publishNewClient&#x27;: { type: &#x27;boolean&#x27; },
      &#x27;publishClientDisconnect&#x27;: { type: &#x27;boolean&#x27; },
      &#x27;publishSubscriptions&#x27;: { type: &#x27;boolean&#x27; }
    }
  });

  var result = validator.validate(opts, &#x27;/Options&#x27;, validationOptions);

  // check required credentials
  if (opts.hasOwnProperty(&#x27;interfaces&#x27;)) {
    var hasCredentials = opts.hasOwnProperty(&#x27;credentials&#x27;);
    var reqCredentials = opts.interfaces.some(function (iface) {
      var req = (iface.type === &#x27;mqtts&#x27; || iface.type === &#x27;https&#x27;);
      var has = iface.hasOwnProperty(&#x27;credentials&#x27;);
      return req &#x26;&#x26; !has;
    });

    if (reqCredentials &#x26;&#x26; !hasCredentials) {
      result.addError(&#x27;one of the defiend interfaces requires credentials&#x27;);
    }
  }

  // TODO: check conflicting backend and ascoltatore

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;stats&#x27;: { type: &#x27;boolean&#x27; },
    &#x27;publishNewClient&#x27;: { type: &#x27;boolean&#x27; },
    &#x27;publishClientDisconnect&#x27;: { type: &#x27;boolean&#x27; },
    &#x27;publishSubscriptions&#x27;: { type: &#x27;boolean&#x27; }
  }
});

var result = validator.<span class="apidocCodeKeywordSpan">validate</span>(opts, &#x27;/Options&#x27;, validationOptions);

// check required credentials
if (opts.hasOwnProperty(&#x27;interfaces&#x27;)) {
  var hasCredentials = opts.hasOwnProperty(&#x27;credentials&#x27;);
  var reqCredentials = opts.interfaces.some(function (iface) {
    var req = (iface.type === &#x27;mqtts&#x27; || iface.type === &#x27;https&#x27;);
    var has = iface.hasOwnProperty(&#x27;credentials&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence" id="apidoc.module.mosca.persistence">module mosca.persistence</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp" id="apidoc.element.mosca.persistence.LevelUp">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel(&#x22;retained&#x22;);
  this._clientSubscriptions = db.sublevel(&#x22;clientSubscriptions&#x22;);
  this._subscriptions = db.sublevel(&#x22;subscriptions&#x22;);
  this._offlinePackets = db.sublevel(&#x22;offlinePackets&#x22;);
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on(&#x22;data&#x22;, function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory" id="apidoc.element.mosca.persistence.Memory">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryPersistence(options, callback) {
  if (!(this instanceof MemoryPersistence)) {
    return new MemoryPersistence(options, callback);
  }

  options = options || {};
  options.db = factory;
  options.path = &#x22;RAM&#x22;;
  LevelUpPersistence.call(this, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo" id="apidoc.element.mosca.persistence.Mongo">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
        <span class="apidocSignatureSpan">(options, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongoPersistence(options, done) {
  if (!(this instanceof MongoPersistence)) {
    return new MongoPersistence(options, done);
  }


  this.options = extend(true, {}, defaults, options);
  this.options.mongo.safe = true;

  // This offlineMessageTimeout(in milliseconds) can set the maximum life time for stored offline messages. This is a
  // Mongo-only feature which relies on TTL index. Since Mongo checks expired entries on a minute-based clock, the
  // actual lifetime is ceil(offlineMessageTimeout/60000) minutes. For this reason, we do not have an unit test
  // for this feature.
  if (options.offlineMessageTimeout) {
    this.options.ttl.packets = options.offlineMessageTimeout;
  }

  var that = this;

  var connected = function(err, db) {
    if (err) {
      if (done) {
        return done(err);
      }
      // we have no way of providing an error handler
      throw err;
    }

    that.db = db;
    steed.parallel([
      function(cb) {
        db.collection(&#x22;subscriptions&#x22;, function(err, coll) {
          that._subscriptions = coll;
          steed.parallel([
            that._subscriptions.ensureIndex.bind(that._subscriptions, &#x22;client&#x22;),
            that._subscriptions.ensureIndex.bind(that._subscriptions, { &#x22;added&#x22;: 1 }, { expireAfterSeconds: Math.round(that.options
.ttl.subscriptions / 1000 )} )
          ], cb);
        });
      },
      function(cb) {
        db.collection(&#x22;packets&#x22;, function(err, coll) {
          if (err) {
            return cb(err);
          }

          that._packets = coll;
          steed.series([
            that._packets.ensureIndex.bind(that._packets, &#x22;client&#x22;),
            function(cb){
              // Check expiration indexes. If not exist, create; If exist but with different TTL, delete and recreate; Otherwise
, do nothing.
              that._packets.indexes(function(error, colIndexes){
                if (error) {
                  cb(error);
                } else {
                  var addedIndexKey = {&#x22;added&#x22;: 1};
                  var addedIndexKeyString = &#x27;added_1&#x27;; // If addedIndex changes, this value should also be changed accordingly.
                  var addedIndexObj = colIndexes.filter(function(obj){
                    return obj.name == addedIndexKeyString;
                  });
                  var packetTTLInSeconds = Math.round(that.options.ttl.packets / 1000);
                  if (addedIndexObj.length &#x3c;= 0 || addedIndexObj[0].expireAfterSeconds != packetTTLInSeconds) {
                    if (addedIndexObj.length &#x3e; 0) {
                      // Different index TTL, recreate index to make sure the TTL is set to the new number.
                      that._packets.dropIndex(addedIndexKeyString, function (error, result){
                        if (error) {
                          cb(error);
                        } else {
                          that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                        }
                      });
                    } else {
                      // Create Index for the first time.
                      that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                    }
                  } else {
                    cb(null);
                  }
                }
              });
            }
          ], cb);
        });
      },
      function(cb) {
        db.collection(&#x22;retained&#x22;, function(err, coll) {
          that._retained = coll;
          that._retained.ensureIndex(&#x22;topic&#x22;, { unique: true }, cb);
        });
      }
    ], function(err) {
      if (done) {
        done(err, that);
      }
    });
  };

  // Connect to the db
  if (options.connection) {
    connected(null, this.options.connection);
  } else {
    MongoClient.connect(this.options.url, this.options.mongo, connected);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis" id="apidoc.element.mosca.persistence.Redis">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisPersistence(options, callback) {
  if (!(this instanceof RedisPersistence)) {
    return new RedisPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);

  this._subMatcher = new Matcher();

  this._client = this._buildClient();
  this._pubSubClient = this._buildClient();
  this._id = shortid.generate();

  this._packetKeyTTL = this.options.ttl.packets;
  this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key
  this._closing = false;
  this._closed = false;

  var fetchAndUpdateLocalSub = function(key, unsubs, retried, cb) {
    that._client.get(key, function(err, result) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          return;
        }
      }

      var subs = JSON.parse(result);
      if (!result || typeof subs !== &#x27;object&#x27;) {
        if (!retried) {
          setTimeout(fetchAndUpdateLocalSub.bind(null, key, unsubs, true, cb), 500);
        } else {
          cb &#x26;&#x26; cb();
        }
        return;
      }

      updateLocalSub(key, subs, unsubs);

      if (cb) {
        cb();
      }
    });
  };

  var updateLocalSub = function(key, subs, unsubs) {
    var xs = key.split(&#x22;:&#x22;);
    var id = key.substr(xs[0].length + xs[1].length + 2);

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.add(sub, id);
    });

    if( unsubs ) {
      unsubs.forEach(function(unsub) {
        that._subMatcher.remove(unsub, id);
      });
    }
  };

  var that = this;

  this._pubSubClient.subscribe(this.options.channel, function(){
    if (that._explicitlyClosed()) {
      return;
    }
    var subsStream = that._client.scanStream({
      match: &#x22;client:sub:*&#x22;,
      count: 25000
    });
    var pipeline = that._client.pipeline();
    var total = 0;
    var done = null;

    subsStream.on(&#x27;data&#x27;, function(moreKeys){
      total += moreKeys.length;
      moreKeys.map(function(k){
        pipeline.get(k, function(err, result) {
          if (err) {
            done &#x26;&#x26; done(err);
            return;
          }
          var subs = JSON.parse(result);
          if (!result || typeof subs !== &#x27;object&#x27;) {
            done &#x26;&#x26; done();
            return;
          }
          updateLocalSub(k, subs);
          done &#x26;&#x26; done();
        });
      });
    });

    subsStream.on(&#x27;end&#x27;, function(){
      if (total === 0) {
        return callback(null, that);
      }
      done = function() {
        if (--total === 0 &#x26;&#x26; callback) {
          callback(null, that);
          callback = null;
        }
      };
      pipeline.exec();
    });
  });

  this._pubSubClient.on(&#x22;message&#x22;, function(channel, message) {
    if (that._explicitlyClosed()) {
      return;
    }
    var parsed = JSON.parse(message);
    if (parsed.process !== that._id) {
      updateLocalSub(parsed.key, parsed.subs, parsed.unsubs);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.getFactory" id="apidoc.element.mosca.persistence.getFactory">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>getFactory
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFactory = function (name) {
  return factories[name.toLowerCase()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    function (done) {
      // REFACTOR: partially move to options.validate and options.populate?
      var persistenceFactory = that.modernOpts.persistence &#x26;&#x26; that.modernOpts.persistence.factory;
      if (persistenceFactory) {
if (typeof persistenceFactory === &#x27;string&#x27;) {
  var factoryName = persistenceFactory;
  persistenceFactory = persistence.<span class="apidocCodeKeywordSpan">getFactory</span>(factoryName);
  if (!persistenceFactory) {
    return callback(new Error(&#x27;No persistence factory found for &#x27; + factoryName ));
  }
}

that.persistence = persistenceFactory(that.modernOpts.persistence, done);
that.persistence.wire(that);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.LevelUp" id="apidoc.module.mosca.persistence.LevelUp">module mosca.persistence.LevelUp</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.LevelUp" id="apidoc.element.mosca.persistence.LevelUp.LevelUp">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel(&#x22;retained&#x22;);
  this._clientSubscriptions = db.sublevel(&#x22;clientSubscriptions&#x22;);
  this._subscriptions = db.sublevel(&#x22;subscriptions&#x22;);
  this._offlinePackets = db.sublevel(&#x22;offlinePackets&#x22;);
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on(&#x22;data&#x22;, function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.super_" id="apidoc.element.mosca.persistence.LevelUp.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.LevelUp.prototype" id="apidoc.module.mosca.persistence.LevelUp.prototype">module mosca.persistence.LevelUp.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype._cleanupStream" id="apidoc.element.mosca.persistence.LevelUp.prototype._cleanupStream">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_cleanupStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanupStream = function (stream) {
  var index = this._streams.indexOf(stream);
  if (index !== -1) {
    this._streams.splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;
var stream = this._subscriptions.createReadStream();
this._streams.push(stream);
stream.on(&#x22;data&#x22;, function(data) {
  that._subMatcher.add(data.value.topic, data.key);
});
stream.on(&#x22;end&#x22;, function() {
  that.<span class="apidocCodeKeywordSpan">_cleanupStream</span>(stream);
  if (callback) {
    callback(null, that);
  }
});
stream.on(&#x22;close&#x22;, function() {
  that._cleanupStream(stream);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype._storePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype._storePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_storePacket
        <span class="apidocSignatureSpan">(client, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_storePacket = function (client, packet, cb) {
  var currentTime = Date.now();
  if (currentTime !== this._lastStoredPacketTime) {
    this._packetCounter = 0;
  }
  this._lastStoredPacketTime = currentTime;
  var key = util.format(&#x22;%s:%d:%d&#x22;, client, currentTime, ++this._packetCounter);
  packet.ttl = this.options.ttl.packets + currentTime;
  this._offlinePackets.put(key, packet, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;
var subs = this._subMatcher.match(packet.topic);
steed.map(from(subs), function(key, cb) {
  that._subscriptions.get(key, function(err, sub) {
    if (err) {
      return cb(err);
    }
    that.<span class="apidocCodeKeywordSpan">_storePacket</span>(sub.client, packet, cb);
  });
}, done);
};

LevelUpPersistence.prototype.streamOfflinePackets = function(client, cb, done) {
var that = this;
var prefix = util.format(&#x27;%s:&#x27;, client.id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.close" id="apidoc.element.mosca.persistence.LevelUp.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this._streams.forEach(function(stream) {
    stream.destroy();
  });
  this.db.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.deleteOfflinePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, done) {
  var that = this;
  var prefix = util.format(&#x27;%s:&#x27;, client.id);
  var found = false;
  var stream = that._offlinePackets.createReadStream({
    start : prefix,
    end : prefix + &#x27;~&#x27;
  });
  this._streams.push(stream);

  stream.on(&#x22;data&#x22;, function(data) {
    if (data.value.messageId !== messageId) {
      return;
    }

    found = true;

    that._offlinePackets.del(data.key, function() {
      if (done) {
        done();
      }
    });
  });

  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
  });

  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });

  if (done) {
    stream.on(&#x22;error&#x22;, done);
    stream.on(&#x22;end&#x22;, function() {
      if (!found) {
        done();
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, &#x22;puback&#x22;);
if (this.inflight[packet.messageId]) {
  this.server.emit(&#x22;delivered&#x22;, this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &#x26;&#x26; that.client.emit(&#x22;error&#x22;, err);
    }
    logger.debug({ packet: packet }, &#x22;cleaned offline packet&#x22;);
  });
} else {
  logger.info({ packet: packet }, &#x22;no matching packet&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupRetained" id="apidoc.element.mosca.persistence.LevelUp.prototype.lookupRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupRetained
        <span class="apidocSignatureSpan">(pattern, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupRetained = function (pattern, cb) {
  var that = this;
  var matched = [];
  var matcher = new Matcher();
  var stream = this._retained.createReadStream();
  this._streams.push(stream);
  matcher.add(pattern, true);

  stream.on(&#x22;error&#x22;, cb);

  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
    cb(null, matched);
  });

  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });

  stream.on(&#x22;data&#x22;, function(data) {
    if (matcher.match(data.key).size &#x3e; 0) {
      matched.push(data.value);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

server.updateOfflinePacket = function(client, messageId, packet, cb) {
  that.updateOfflinePacket(client, messageId, packet, cb);
};

server.forwardRetained = function(pattern, client, done) {
  that.<span class="apidocCodeKeywordSpan">lookupRetained</span>(pattern, function(err, matches) {
    if (err) {
      client.connection.emit(&#x22;error&#x22;, err);
      return;
    }
    steed.each(matches, function(match, cb) {
      client.forward(match.topic, match.payload, match, pattern, match.qos, cb);
    }, done);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupSubscriptions" id="apidoc.element.mosca.persistence.LevelUp.prototype.lookupSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupSubscriptions = function (client, done) {
  var that = this;
  this._clientSubscriptions.get(client.id, function(err, subscriptions) {
    var toRemove = [];

    subscriptions = subscriptions || {};

    Object.keys(subscriptions).forEach(function(key) {
      var levelKey = util.format(&#x22;%s:%s&#x22;, key, client.id);
      if (subscriptions[key].ttl &#x3c;= Date.now()) {
        delete subscriptions[key];
        that._subMatcher.remove(key, levelKey);
        toRemove.push(levelKey);
      }
    });

    if (client.clean) {
      that._clientSubscriptions.del(client.id, function() {
        Object.keys(subscriptions).forEach(function(key) {
          // TODO we need to remove these from the subMatcher every time.
          var levelKey = util.format(&#x22;%s:%s&#x22;, key, client.id);
          that._subMatcher.remove(key, levelKey);
          toRemove.push(levelKey);
        });

        that.streamOfflinePackets(client, nop, function() {
          that._subscriptions.batch(toRemove.map(function(levelKey) {
            return {
              key: levelKey,
              type: &#x27;del&#x27;
            };
          }), function(err) {
            done(err, {});
          });
        });
      });
    } else if (done) {
      done(null, subscriptions);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  server.on(&#x22;close&#x22;, function() {
    that.close();
  });

  server.restoreClientSubscriptions = function restoreClientSubscriptions(client, done) {
    that.<span class="apidocCodeKeywordSpan">lookupSubscriptions</span>(client, function(err, subscriptions) {
if (err) {
  client.connection.emit(&#x22;error&#x22;, err);
  return;
}

var subs = Object.keys(subscriptions);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeOfflinePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype.storeOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeOfflinePacket
        <span class="apidocSignatureSpan">(packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeOfflinePacket = function (packet, done) {
  var that = this;
  var subs = this._subMatcher.match(packet.topic);
  steed.map(from(subs), function(key, cb) {
    that._subscriptions.get(key, function(err, sub) {
      if (err) {
        return cb(err);
      }
      that._storePacket(sub.client, packet, cb);
    });
  }, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
  if (packet.retain) {
    total++;
    that.storeRetained(packet, done);
  }
  if (packet.qos !== 0 || that.options.storeMessagesQos0) {
    total++;
    that.<span class="apidocCodeKeywordSpan">storeOfflinePacket</span>(packet, done);
  }
  done();
};

server.deleteOfflinePacket = function(client, messageId, cb) {
  that.deleteOfflinePacket(client, messageId, cb);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeRetained" id="apidoc.element.mosca.persistence.LevelUp.prototype.storeRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeRetained
        <span class="apidocSignatureSpan">(packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeRetained = function (packet, cb) {
  if (packet.payload.length &#x3e; 0) {
    this._retained.put(packet.topic, packet, cb);
  } else {
    this._retained.del(packet.topic, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var done = function() {
    if (--total === 0 &#x26;&#x26; cb) {
      cb();
    }
  };
  if (packet.retain) {
    total++;
    that.<span class="apidocCodeKeywordSpan">storeRetained</span>(packet, done);
  }
  if (packet.qos !== 0 || that.options.storeMessagesQos0) {
    total++;
    that.storeOfflinePacket(packet, done);
  }
  done();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeSubscriptions" id="apidoc.element.mosca.persistence.LevelUp.prototype.storeSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeSubscriptions = function (client, done) {
  var that = this;
  var subscriptions = {};
  var now = Date.now();

  if (!client.clean) {
    Object.keys(client.subscriptions).forEach(function(key) {
      if (client.subscriptions[key].qos &#x3e; 0) {
        subscriptions[key] = client.subscriptions[key];
        subscriptions[key].ttl = that.options.ttl.subscriptions + now;
      }
    });
    this._clientSubscriptions.put(client.id, subscriptions, done);
    Object.keys(subscriptions).forEach(function(key) {
      var sub = {
        client: client.id,
        topic: key,
        ttl: that.options.ttl.subscriptions + now,
        qos: subscriptions[key].qos
      };
      var levelKey = util.format(&#x22;%s:%s&#x22;, key, client.id);
      that._subMatcher.add(key, levelKey);
      that._subscriptions.put(levelKey, sub);
    });
  } else if (done) {
    done();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     client.logger.debug({ packet: packet }, &#x22;Forwarding offline packet&#x22;);
     client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
   }, done);
 };

 server.persistClient = function(client, done) {
   client.logger.debug(&#x22;Storing offline subscriptions&#x22;);
   that.<span class="apidocCodeKeywordSpan">storeSubscriptions</span>(client, done);
 };
};

/**
* Close the persistance.
*
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.streamOfflinePackets" id="apidoc.element.mosca.persistence.LevelUp.prototype.streamOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>streamOfflinePackets
        <span class="apidocSignatureSpan">(client, cb, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamOfflinePackets = function (client, cb, done) {
  var that = this;
  var prefix = util.format(&#x27;%s:&#x27;, client.id);
  var count = 0;
  var ended = false;
  var stream = that._offlinePackets.createReadStream({
    start : prefix,
    end : prefix + &#x27;~&#x27;
  });
  this._streams.push(stream);

  stream.on(&#x22;data&#x22;, function(data) {

    if (client.clean || data.value.ttl &#x3c;= Date.now()) {
      count++;
      that._offlinePackets.del(data.key, function() {
        count--;

	// for testing
        if (ended &#x26;&#x26; count === 0 &#x26;&#x26; done) {
          done();
        }
      });
    } else {
      cb(null, data.value);
    }
  });

  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
    ended = true;

    // for testing
    if (count === 0 &#x26;&#x26; done) {
      done();
    }
  });

  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });

  // for testing
  if (done) {
    stream.on(&#x22;error&#x22;, done);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.forwardOfflinePackets = function(client, done) {
  // do not waste cpu time find in stored packets...
  // if client is clean lookupSubscriptions already delete stored packets
  if(client.clean)
    return done &#x26;&#x26; done();

  that.<span class="apidocCodeKeywordSpan">streamOfflinePackets</span>(client, function(err, packet) {
    packet.offline = true;
    client.logger.debug({ packet: packet }, &#x22;Forwarding offline packet&#x22;);
    client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
  }, done);
};

server.persistClient = function(client, done) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.updateOfflinePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, messageId, packet, done) {
  var that = this;
  var prefix = util.format(&#x27;%s:&#x27;, client.id);
  var found = false;
  var stream = that._offlinePackets.createReadStream({
    start : prefix,
    end : prefix + &#x27;~&#x27;
  });
  this._streams.push(stream);

  stream.on(&#x22;data&#x22;, function(data) {
    if (data.value.messageId !== messageId) {
      return;
    }

    found = true;

    data.value.messageId = packet.messageId;

    that._offlinePackets.put(data.key, data.value, function() {
      if (done) {
        done(null, packet);
      }
    });
  });

  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
  });

  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });

  if (done) {
    stream.on(&#x22;error&#x22;, done);
    stream.on(&#x22;end&#x22;, function() {
      if (!found) {
        done(null, packet);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &#x26;&#x26; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.LevelUp.super_.prototype" id="apidoc.module.mosca.persistence.LevelUp.super_.prototype">module mosca.persistence.LevelUp.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.close" id="apidoc.element.mosca.persistence.LevelUp.super_.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (done) {
  if (done) {
    done(new Error(&#x22;not implemented yet&#x22;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.wire" id="apidoc.element.mosca.persistence.LevelUp.super_.prototype.wire">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>wire
        <span class="apidocSignatureSpan">(server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wire = function (server) {
  var that = this;
  var nop = function() {};
  server.persistence = this;

  server.storePacket = function(packet, cb) {

    // store qos 0 packets only if storeMessagesQos0 is true or retain is true
    if(packet.qos === 0 &#x26;&#x26; packet.retain === false &#x26;&#x26; ! that.options.storeMessagesQos0){
      return cb();
    }

    var total = 1;
    var done = function() {
      if (--total === 0 &#x26;&#x26; cb) {
        cb();
      }
    };
    if (packet.retain) {
      total++;
      that.storeRetained(packet, done);
    }
    if (packet.qos !== 0 || that.options.storeMessagesQos0) {
      total++;
      that.storeOfflinePacket(packet, done);
    }
    done();
  };

  server.deleteOfflinePacket = function(client, messageId, cb) {
    that.deleteOfflinePacket(client, messageId, cb);
  };

  server.updateOfflinePacket = function(client, messageId, packet, cb) {
    that.updateOfflinePacket(client, messageId, packet, cb);
  };

  server.forwardRetained = function(pattern, client, done) {
    that.lookupRetained(pattern, function(err, matches) {
      if (err) {
        client.connection.emit(&#x22;error&#x22;, err);
        return;
      }
      steed.each(matches, function(match, cb) {
        client.forward(match.topic, match.payload, match, pattern, match.qos, cb);
      }, done);
    });
  };

  server.on(&#x22;close&#x22;, function() {
    that.close();
  });

  server.restoreClientSubscriptions = function restoreClientSubscriptions(client, done) {
    that.lookupSubscriptions(client, function(err, subscriptions) {
      if (err) {
        client.connection.emit(&#x22;error&#x22;, err);
        return;
      }

      var subs = Object.keys(subscriptions);

      steed.each(subs, function(topic, inCb) {
        client.logger.debug({ topic: topic, qos: subscriptions[topic].qos }, &#x22;restoring subscription&#x22;);
        client.handleAuthorizeSubscribe(
          null, true, {
          topic: topic,
          qos: subscriptions[topic].qos
        }, inCb);
      }, function(){done(subs.length === 0 ? false : true);});
    });
  };

  server.forwardOfflinePackets = function(client, done) {
    // do not waste cpu time find in stored packets...
    // if client is clean lookupSubscriptions already delete stored packets
    if(client.clean)
      return done &#x26;&#x26; done();

    that.streamOfflinePackets(client, function(err, packet) {
      packet.offline = true;
      client.logger.debug({ packet: packet }, &#x22;Forwarding offline packet&#x22;);
      client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
    }, done);
  };

  server.persistClient = function(client, done) {
    client.logger.debug(&#x22;Storing offline subscriptions&#x22;);
    that.storeSubscriptions(client, done);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  delete this.modernOpts.logger.name;
  this.logger = this.logger.child(this.modernOpts.logger);
} else {
  this.logger = pino(this.modernOpts.logger);
}

if(this.modernOpts.stats) {
  new Stats().<span class="apidocCodeKeywordSpan">wire</span>(this);
}

var that = this;

// each Server has a dummy id for logging purposes
this.id = this.modernOpts.id || shortid.generate();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Memory" id="apidoc.module.mosca.persistence.Memory">module mosca.persistence.Memory</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory.Memory" id="apidoc.element.mosca.persistence.Memory.Memory">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryPersistence(options, callback) {
  if (!(this instanceof MemoryPersistence)) {
    return new MemoryPersistence(options, callback);
  }

  options = options || {};
  options.db = factory;
  options.path = &#x22;RAM&#x22;;
  LevelUpPersistence.call(this, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory.super_" id="apidoc.element.mosca.persistence.Memory.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.Memory.</span>super_
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel(&#x22;retained&#x22;);
  this._clientSubscriptions = db.sublevel(&#x22;clientSubscriptions&#x22;);
  this._subscriptions = db.sublevel(&#x22;subscriptions&#x22;);
  this._offlinePackets = db.sublevel(&#x22;offlinePackets&#x22;);
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on(&#x22;data&#x22;, function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on(&#x22;end&#x22;, function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on(&#x22;close&#x22;, function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Memory.prototype" id="apidoc.module.mosca.persistence.Memory.prototype">module mosca.persistence.Memory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory.prototype.close" id="apidoc.element.mosca.persistence.Memory.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.Memory.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {

  MemDOWN.clearGlobalStore();

  this._streams.forEach(function(stream) {
    stream.destroy();
  });
  this.db.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Mongo" id="apidoc.module.mosca.persistence.Mongo">module mosca.persistence.Mongo</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.Mongo" id="apidoc.element.mosca.persistence.Mongo.Mongo">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
        <span class="apidocSignatureSpan">(options, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongoPersistence(options, done) {
  if (!(this instanceof MongoPersistence)) {
    return new MongoPersistence(options, done);
  }


  this.options = extend(true, {}, defaults, options);
  this.options.mongo.safe = true;

  // This offlineMessageTimeout(in milliseconds) can set the maximum life time for stored offline messages. This is a
  // Mongo-only feature which relies on TTL index. Since Mongo checks expired entries on a minute-based clock, the
  // actual lifetime is ceil(offlineMessageTimeout/60000) minutes. For this reason, we do not have an unit test
  // for this feature.
  if (options.offlineMessageTimeout) {
    this.options.ttl.packets = options.offlineMessageTimeout;
  }

  var that = this;

  var connected = function(err, db) {
    if (err) {
      if (done) {
        return done(err);
      }
      // we have no way of providing an error handler
      throw err;
    }

    that.db = db;
    steed.parallel([
      function(cb) {
        db.collection(&#x22;subscriptions&#x22;, function(err, coll) {
          that._subscriptions = coll;
          steed.parallel([
            that._subscriptions.ensureIndex.bind(that._subscriptions, &#x22;client&#x22;),
            that._subscriptions.ensureIndex.bind(that._subscriptions, { &#x22;added&#x22;: 1 }, { expireAfterSeconds: Math.round(that.options
.ttl.subscriptions / 1000 )} )
          ], cb);
        });
      },
      function(cb) {
        db.collection(&#x22;packets&#x22;, function(err, coll) {
          if (err) {
            return cb(err);
          }

          that._packets = coll;
          steed.series([
            that._packets.ensureIndex.bind(that._packets, &#x22;client&#x22;),
            function(cb){
              // Check expiration indexes. If not exist, create; If exist but with different TTL, delete and recreate; Otherwise
, do nothing.
              that._packets.indexes(function(error, colIndexes){
                if (error) {
                  cb(error);
                } else {
                  var addedIndexKey = {&#x22;added&#x22;: 1};
                  var addedIndexKeyString = &#x27;added_1&#x27;; // If addedIndex changes, this value should also be changed accordingly.
                  var addedIndexObj = colIndexes.filter(function(obj){
                    return obj.name == addedIndexKeyString;
                  });
                  var packetTTLInSeconds = Math.round(that.options.ttl.packets / 1000);
                  if (addedIndexObj.length &#x3c;= 0 || addedIndexObj[0].expireAfterSeconds != packetTTLInSeconds) {
                    if (addedIndexObj.length &#x3e; 0) {
                      // Different index TTL, recreate index to make sure the TTL is set to the new number.
                      that._packets.dropIndex(addedIndexKeyString, function (error, result){
                        if (error) {
                          cb(error);
                        } else {
                          that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                        }
                      });
                    } else {
                      // Create Index for the first time.
                      that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                    }
                  } else {
                    cb(null);
                  }
                }
              });
            }
          ], cb);
        });
      },
      function(cb) {
        db.collection(&#x22;retained&#x22;, function(err, coll) {
          that._retained = coll;
          that._retained.ensureIndex(&#x22;topic&#x22;, { unique: true }, cb);
        });
      }
    ], function(err) {
      if (done) {
        done(err, that);
      }
    });
  };

  // Connect to the db
  if (options.connection) {
    connected(null, this.options.connection);
  } else {
    MongoClient.connect(this.options.url, this.options.mongo, connected);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.super_" id="apidoc.element.mosca.persistence.Mongo.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Mongo.prototype" id="apidoc.module.mosca.persistence.Mongo.prototype">module mosca.persistence.Mongo.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype._storePacket" id="apidoc.element.mosca.persistence.Mongo.prototype._storePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>_storePacket
        <span class="apidocSignatureSpan">(client, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_storePacket = function (client, packet, cb) {
  var toStore = {
    client: client,
    packet: packet,
    added: new Date()
  };

  this._packets.insert(toStore, {w:1}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;
var subs = this._subMatcher.match(packet.topic);
steed.map(from(subs), function(key, cb) {
  that._subscriptions.get(key, function(err, sub) {
    if (err) {
      return cb(err);
    }
    that.<span class="apidocCodeKeywordSpan">_storePacket</span>(sub.client, packet, cb);
  });
}, done);
};

LevelUpPersistence.prototype.streamOfflinePackets = function(client, cb, done) {
var that = this;
var prefix = util.format(&#x27;%s:&#x27;, client.id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.close" id="apidoc.element.mosca.persistence.Mongo.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  if (this.db &#x26;&#x26; this.options.autoClose !== false) {
    this.db.close(cb);
  } else {
    cb();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.deleteOfflinePacket" id="apidoc.element.mosca.persistence.Mongo.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, cb) {
  var toSearch = {
    client: client.id,
    &#x27;packet.messageId&#x27;: messageId
  };

  this._packets.remove(toSearch, {w:1}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, &#x22;puback&#x22;);
if (this.inflight[packet.messageId]) {
  this.server.emit(&#x22;delivered&#x22;, this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &#x26;&#x26; that.client.emit(&#x22;error&#x22;, err);
    }
    logger.debug({ packet: packet }, &#x22;cleaned offline packet&#x22;);
  });
} else {
  logger.info({ packet: packet }, &#x22;no matching packet&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupRetained" id="apidoc.element.mosca.persistence.Mongo.prototype.lookupRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupRetained
        <span class="apidocSignatureSpan">(pattern, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupRetained = function (pattern, cb) {
  var regexp = new RegExp(pattern.replace(/(#|\+)/, &#x22;.+&#x22;).replace(&#x27;\\&#x27;, &#x27;\\\\&#x27;));
  var stream = this._retained.find({ topic: { $regex: regexp } }).stream();
  var matched = [];
  var matcher = new Matcher();
  matcher.add(pattern, true);

  stream.on(&#x22;error&#x22;, cb);

  stream.on(&#x22;end&#x22;, function() {
    cb(null, matched);
  });

  stream.on(&#x22;data&#x22;, function(data) {
    if (matcher.match(data.topic).size &#x3e; 0) {
      data.payload = data.payload.buffer;
      matched.push(data);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

server.updateOfflinePacket = function(client, messageId, packet, cb) {
  that.updateOfflinePacket(client, messageId, packet, cb);
};

server.forwardRetained = function(pattern, client, done) {
  that.<span class="apidocCodeKeywordSpan">lookupRetained</span>(pattern, function(err, matches) {
    if (err) {
      client.connection.emit(&#x22;error&#x22;, err);
      return;
    }
    steed.each(matches, function(match, cb) {
      client.forward(match.topic, match.payload, match, pattern, match.qos, cb);
    }, done);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupSubscriptions" id="apidoc.element.mosca.persistence.Mongo.prototype.lookupSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupSubscriptions = function (client, done) {
  var that = this;
  this._subscriptions.find({ client: client.id })
                     .toArray(function(err, subscriptions) {

    var now = Date.now();

    subscriptions = (subscriptions || []).reduce(function(obj, sub) {
      // mongodb TTL is not precise
      if (sub.added.getTime() + that.options.ttl.subscriptions &#x3e; now) {
        obj[sub.topic] = {
          qos: sub.qos
        };
      }
      return obj;
    }, {});

    if (!client.clean) {
      done(err, subscriptions);
      return;
    }

    var toExecute = [
      function removeSubscriptions(cb) {
        that._subscriptions.remove({ client: client.id }, cb);
      },
      function removePackets(cb) {
        that._packets.remove({ client: client.id }, cb);
      }
    ];

    steed.parallel(toExecute, function(err) {
      done(null, {});
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  server.on(&#x22;close&#x22;, function() {
    that.close();
  });

  server.restoreClientSubscriptions = function restoreClientSubscriptions(client, done) {
    that.<span class="apidocCodeKeywordSpan">lookupSubscriptions</span>(client, function(err, subscriptions) {
if (err) {
  client.connection.emit(&#x22;error&#x22;, err);
  return;
}

var subs = Object.keys(subscriptions);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.storeOfflinePacket" id="apidoc.element.mosca.persistence.Mongo.prototype.storeOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeOfflinePacket
        <span class="apidocSignatureSpan">(packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeOfflinePacket = function (packet, done) {

  var patterns = topicPatterns(packet.topic);

  var stream = this._subscriptions.find({ topic: { $in: patterns } }).stream();
  var ended = false;
  var completed = 0;
  var started = 0;
  var that = this;

  if (done) {
    stream.on(&#x22;error&#x22;, done);
  }

  stream.on(&#x22;data&#x22;, function(data) {
    started++;

    that._storePacket(data.client, packet, function(err) {
      if (err) {
        return stream.emit(&#x22;error&#x22;, err);
      }

      // TODO handle the err in case of no callback
      completed++;

      if (done &#x26;&#x26; ended &#x26;&#x26; started === completed) {
        done();
      }
    });
  });

  stream.on(&#x22;end&#x22;, function() {
    ended = true;
    if (done &#x26;&#x26; started === completed) {
      done();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
  if (packet.retain) {
    total++;
    that.storeRetained(packet, done);
  }
  if (packet.qos !== 0 || that.options.storeMessagesQos0) {
    total++;
    that.<span class="apidocCodeKeywordSpan">storeOfflinePacket</span>(packet, done);
  }
  done();
};

server.deleteOfflinePacket = function(client, messageId, cb) {
  that.deleteOfflinePacket(client, messageId, cb);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.storeRetained" id="apidoc.element.mosca.persistence.Mongo.prototype.storeRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeRetained
        <span class="apidocSignatureSpan">(packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeRetained = function (packet, cb) {
  if (packet.payload.length &#x3e; 0) {
    this._retained.update(
      { topic: packet.topic },
      packet,
      {
        upsert: true,
        w: 1
      },
      function(err, n, result){
        if(cb) {
          return cb(err);
        }
      });
  } else {
    this._retained.remove(
      { topic: packet.topic },
      { w: 1 },
      cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var done = function() {
    if (--total === 0 &#x26;&#x26; cb) {
      cb();
    }
  };
  if (packet.retain) {
    total++;
    that.<span class="apidocCodeKeywordSpan">storeRetained</span>(packet, done);
  }
  if (packet.qos !== 0 || that.options.storeMessagesQos0) {
    total++;
    that.storeOfflinePacket(packet, done);
  }
  done();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.storeSubscriptions" id="apidoc.element.mosca.persistence.Mongo.prototype.storeSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeSubscriptions = function (client, done) {

  var subscriptions;
  var that = this;

  if (!client.clean) {
    subscriptions = Object.keys(client.subscriptions).filter(function(key) {
      return client.subscriptions[key].qos &#x3e; 0;
    });

    steed.each(subscriptions, function(key, cb) {
      that._subscriptions.findAndModify({
        client: client.id,
        topic: key
      }, [[&#x27;date&#x27;, -1]], {
        $set: {
          client: client.id,
          topic: key,
          qos: client.subscriptions[key].qos,
          added: new Date()
        }
      }, { upsert: true}, cb);
    }, done);
  } else if (done) {
    return done();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     client.logger.debug({ packet: packet }, &#x22;Forwarding offline packet&#x22;);
     client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
   }, done);
 };

 server.persistClient = function(client, done) {
   client.logger.debug(&#x22;Storing offline subscriptions&#x22;);
   that.<span class="apidocCodeKeywordSpan">storeSubscriptions</span>(client, done);
 };
};

/**
* Close the persistance.
*
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.streamOfflinePackets" id="apidoc.element.mosca.persistence.Mongo.prototype.streamOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>streamOfflinePackets
        <span class="apidocSignatureSpan">(client, cb, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamOfflinePackets = function (client, cb, done) {

  var stream = this._packets.find({ client: client.id }).stream();
  var that = this;

  var now = Date.now();

  // for testing
  if(done)
    stream.on(&#x22;end&#x22;, done);

  stream.on(&#x22;error&#x22;, cb);

  stream.on(&#x22;data&#x22;, function(data) {
    // mongodb TTL is not precise
    // mongodb automaticly remove the packet
    if (data.added.getTime() + that.options.ttl.packets &#x3e; now) {
      data.packet.payload = data.packet.payload.buffer;
      cb(null, data.packet);
    }
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.forwardOfflinePackets = function(client, done) {
  // do not waste cpu time find in stored packets...
  // if client is clean lookupSubscriptions already delete stored packets
  if(client.clean)
    return done &#x26;&#x26; done();

  that.<span class="apidocCodeKeywordSpan">streamOfflinePackets</span>(client, function(err, packet) {
    packet.offline = true;
    client.logger.debug({ packet: packet }, &#x22;Forwarding offline packet&#x22;);
    client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
  }, done);
};

server.persistClient = function(client, done) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.updateOfflinePacket" id="apidoc.element.mosca.persistence.Mongo.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, messageId, packet, cb) {
  this._packets.update({
    client: client.id,
    &#x27;packet.messageId&#x27;: messageId
  }, {
    $set: { &#x27;packet.messageId&#x27;: packet.messageId }
  }, {w:1}, function(err) {
    cb(err, packet);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &#x26;&#x26; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Redis" id="apidoc.module.mosca.persistence.Redis">module mosca.persistence.Redis</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.Redis" id="apidoc.element.mosca.persistence.Redis.Redis">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisPersistence(options, callback) {
  if (!(this instanceof RedisPersistence)) {
    return new RedisPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);

  this._subMatcher = new Matcher();

  this._client = this._buildClient();
  this._pubSubClient = this._buildClient();
  this._id = shortid.generate();

  this._packetKeyTTL = this.options.ttl.packets;
  this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key
  this._closing = false;
  this._closed = false;

  var fetchAndUpdateLocalSub = function(key, unsubs, retried, cb) {
    that._client.get(key, function(err, result) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          return;
        }
      }

      var subs = JSON.parse(result);
      if (!result || typeof subs !== &#x27;object&#x27;) {
        if (!retried) {
          setTimeout(fetchAndUpdateLocalSub.bind(null, key, unsubs, true, cb), 500);
        } else {
          cb &#x26;&#x26; cb();
        }
        return;
      }

      updateLocalSub(key, subs, unsubs);

      if (cb) {
        cb();
      }
    });
  };

  var updateLocalSub = function(key, subs, unsubs) {
    var xs = key.split(&#x22;:&#x22;);
    var id = key.substr(xs[0].length + xs[1].length + 2);

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.add(sub, id);
    });

    if( unsubs ) {
      unsubs.forEach(function(unsub) {
        that._subMatcher.remove(unsub, id);
      });
    }
  };

  var that = this;

  this._pubSubClient.subscribe(this.options.channel, function(){
    if (that._explicitlyClosed()) {
      return;
    }
    var subsStream = that._client.scanStream({
      match: &#x22;client:sub:*&#x22;,
      count: 25000
    });
    var pipeline = that._client.pipeline();
    var total = 0;
    var done = null;

    subsStream.on(&#x27;data&#x27;, function(moreKeys){
      total += moreKeys.length;
      moreKeys.map(function(k){
        pipeline.get(k, function(err, result) {
          if (err) {
            done &#x26;&#x26; done(err);
            return;
          }
          var subs = JSON.parse(result);
          if (!result || typeof subs !== &#x27;object&#x27;) {
            done &#x26;&#x26; done();
            return;
          }
          updateLocalSub(k, subs);
          done &#x26;&#x26; done();
        });
      });
    });

    subsStream.on(&#x27;end&#x27;, function(){
      if (total === 0) {
        return callback(null, that);
      }
      done = function() {
        if (--total === 0 &#x26;&#x26; callback) {
          callback(null, that);
          callback = null;
        }
      };
      pipeline.exec();
    });
  });

  this._pubSubClient.on(&#x22;message&#x22;, function(channel, message) {
    if (that._explicitlyClosed()) {
      return;
    }
    var parsed = JSON.parse(message);
    if (parsed.process !== that._id) {
      updateLocalSub(parsed.key, parsed.subs, parsed.unsubs);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.super_" id="apidoc.element.mosca.persistence.Redis.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Redis.prototype" id="apidoc.module.mosca.persistence.Redis.prototype">module mosca.persistence.Redis.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._buildClient" id="apidoc.element.mosca.persistence.Redis.prototype._buildClient">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_buildClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_buildClient = function () {
  var options = this.options.redisOptions || {};

  if (this.options.url) {
    options.url = this.options.url;
  }

  if (this.options.host) {
    options.host = this.options.host;
  }

  if (this.options.port) {
    options.port = this.options.port;
  }

  if (this.options.db) {
    options.db = this.options.db;
  }

  if (this.options.password) {
    options.password = this.options.password;
  }

  return new Redis(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new RedisPersistence(options, callback);
}

this.options = extend(true, {}, defaults, options);

this._subMatcher = new Matcher();

this._client = this.<span class="apidocCodeKeywordSpan">_buildClient</span>();
this._pubSubClient = this._buildClient();
this._id = shortid.generate();

this._packetKeyTTL = this.options.ttl.packets;
this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key
this._closing = false;
this._closed = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._cleanClient" id="apidoc.element.mosca.persistence.Redis.prototype._cleanClient">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_cleanClient
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanClient = function (client, done) {
  var that = this;

  var key = &#x22;client:sub:&#x22; + client.id;

  this._client.get(key, function(err, subs) {
    subs = JSON.parse(subs) || {};

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.remove(sub, client.id);
    });

    steed.parallel([
      function(cb) {
        that._client.del(key, cb);
      },
      function(cb) {
        that._client.del(&#x22;packets:&#x22; + client.id, cb);
      }
    ], function(err) {
      if (done) {
        done(err, {});
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

RedisPersistence.prototype.lookupSubscriptions = function(client, cb) {
  if (this._explicitlyClosed()) {
return cb &#x26;&#x26; cb(new Error(&#x27;Explicitly closed&#x27;));
  }

  if (client.clean) {
this.<span class="apidocCodeKeywordSpan">_cleanClient</span>(client, cb);
  }else{
var key = &#x22;client:sub:&#x22; + client.id;
var subscriptions;

var multi = this._client.multi();

multi.get(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._explicitlyClosed" id="apidoc.element.mosca.persistence.Redis.prototype._explicitlyClosed">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_explicitlyClosed
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_explicitlyClosed = function (done) {
  return this._closing || this._closed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
  }
};

var that = this;

this._pubSubClient.subscribe(this.options.channel, function(){
  if (that.<span class="apidocCodeKeywordSpan">_explicitlyClosed</span>()) {
    return;
  }
  var subsStream = that._client.scanStream({
    match: &#x22;client:sub:*&#x22;,
    count: 25000
  });
  var pipeline = that._client.pipeline();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._storePacket" id="apidoc.element.mosca.persistence.Redis.prototype._storePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_storePacket
        <span class="apidocSignatureSpan">(client, packet, pipeline, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_storePacket = function (client, packet, pipeline, cb) {
  if (this._explicitlyClosed()) {
    return cb &#x26;&#x26; cb(new Error(&#x27;Explicitly closed&#x27;));
  }

  var packetKey = &#x22;packets:&#x22; + client + &#x22;:&#x22; + packet.messageId,
      listKey = &#x22;packets:&#x22; + client;

  pipeline.multi()
    .set(packetKey, JSON.stringify(packet))
    .pexpire(packetKey, this._packetKeyTTL)
    .rpush(listKey, packetKey)
    .pexpire(listKey, this._listKeyTTL)
    .exec();

  cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;
var subs = this._subMatcher.match(packet.topic);
steed.map(from(subs), function(key, cb) {
  that._subscriptions.get(key, function(err, sub) {
    if (err) {
      return cb(err);
    }
    that.<span class="apidocCodeKeywordSpan">_storePacket</span>(sub.client, packet, cb);
  });
}, done);
};

LevelUpPersistence.prototype.streamOfflinePackets = function(client, cb, done) {
var that = this;
var prefix = util.format(&#x27;%s:&#x27;, client.id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.close" id="apidoc.element.mosca.persistence.Redis.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>close
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (done) {
  if (this._closed) {
    return done &#x26;&#x26; done();
  }
  if (this._closing) {
    return done &#x26;&#x26; this.once(&#x27;close&#x27;, done);
  }
  this._closing = true;

  var that = this;

  steed.each([
    &#x22;_client&#x22;, &#x22;_pubSubClient&#x22;
  ], function(client, cb) {
    if (that[client]) {
      that[client].quit(function quit(err) {
        delete that[client];
        cb(err);
      });
    } else {
      cb();
    }
  }, function() {
    that._closed = true;
    that.emit(&#x27;close&#x27;);
    done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on(&#x22;unsubscribe&#x22;, function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, &#x22;unsubscribe received&#x22;);
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.deleteOfflinePacket" id="apidoc.element.mosca.persistence.Redis.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, done) {
  if (this._explicitlyClosed()) {
    return done &#x26;&#x26; done(new Error(&#x27;Explicitly closed&#x27;));
  }

  var that = this;
  var packetKey = &#x22;packets:&#x22; + client.id + &#x22;:&#x22; + messageId;

  this._client.multi()
    .del(packetKey)
    .lrem(&#x22;packets:&#x22; + client.id, 1, packetKey)
    .exec(done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, &#x22;puback&#x22;);
if (this.inflight[packet.messageId]) {
  this.server.emit(&#x22;delivered&#x22;, this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &#x26;&#x26; that.client.emit(&#x22;error&#x22;, err);
    }
    logger.debug({ packet: packet }, &#x22;cleaned offline packet&#x22;);
  });
} else {
  logger.info({ packet: packet }, &#x22;no matching packet&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.lookupRetained" id="apidoc.element.mosca.persistence.Redis.prototype.lookupRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupRetained
        <span class="apidocSignatureSpan">(pattern, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupRetained = function (pattern, done) {
  if (this._explicitlyClosed()) {
    return done &#x26;&#x26; done(new Error(&#x27;Explicitly closed&#x27;));
  }
  var that = this;
  var matched = [];
  var match = function(topic, cb) {
    that._client.hget(&#x22;retained&#x22;, topic, function(err, packet) {
      if (packet) {

        packet = JSON.parse(packet);
        packet.payload = new Buffer(packet.payload);

        matched.push(packet);
      }

      cb(err, matched);
    });
  };

  if (pattern.indexOf(&#x22;#&#x22;) &#x3e;= 0 || pattern.indexOf(&#x22;+&#x22;) &#x3e;= 0) {
    var matcher = new Matcher();
    matcher.add(pattern, true);

    this._client.hkeys(&#x22;retained&#x22;, function(err, topics) {
      topics.sort();
      topics = topics.filter(function(topic) {
        return matcher.match(topic).size &#x3e; 0;
      });

      steed.each(topics, match, function(err) {
        done(err, matched);
      });
    });

    // do something
  } else {
    match(pattern, done);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

server.updateOfflinePacket = function(client, messageId, packet, cb) {
  that.updateOfflinePacket(client, messageId, packet, cb);
};

server.forwardRetained = function(pattern, client, done) {
  that.<span class="apidocCodeKeywordSpan">lookupRetained</span>(pattern, function(err, matches) {
    if (err) {
      client.connection.emit(&#x22;error&#x22;, err);
      return;
    }
    steed.each(matches, function(match, cb) {
      client.forward(match.topic, match.payload, match, pattern, match.qos, cb);
    }, done);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.lookupSubscriptions" id="apidoc.element.mosca.persistence.Redis.prototype.lookupSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupSubscriptions
        <span class="apidocSignatureSpan">(client, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupSubscriptions = function (client, cb) {
  if (this._explicitlyClosed()) {
    return cb &#x26;&#x26; cb(new Error(&#x27;Explicitly closed&#x27;));
  }

  if (client.clean) {
    this._cleanClient(client, cb);
  }else{
    var key = &#x22;client:sub:&#x22; + client.id;
    var subscriptions;

    var multi = this._client.multi();

    multi.get(key);

    multi.exec(function(err, result) {
      subscriptions = JSON.parse(result[0][1]) || {};
      cb(err, subscriptions);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  server.on(&#x22;close&#x22;, function() {
    that.close();
  });

  server.restoreClientSubscriptions = function restoreClientSubscriptions(client, done) {
    that.<span class="apidocCodeKeywordSpan">lookupSubscriptions</span>(client, function(err, subscriptions) {
if (err) {
  client.connection.emit(&#x22;error&#x22;, err);
  return;
}

var subs = Object.keys(subscriptions);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.storeOfflinePacket" id="apidoc.element.mosca.persistence.Redis.prototype.storeOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeOfflinePacket
        <span class="apidocSignatureSpan">(packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeOfflinePacket = function (packet, done) {
  if (this._explicitlyClosed()) {
    return done &#x26;&#x26; done(new Error(&#x27;Explicitly closed&#x27;));
  }

  var that = this;

  var matches = this._subMatcher.match(packet.topic);
  var pipeline = this._client.pipeline();
  steed.each(from(matches), function(client, cb) {
    that._storePacket(client, packet, pipeline, cb);
  }, function(){
    pipeline.exec(done);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
  if (packet.retain) {
    total++;
    that.storeRetained(packet, done);
  }
  if (packet.qos !== 0 || that.options.storeMessagesQos0) {
    total++;
    that.<span class="apidocCodeKeywordSpan">storeOfflinePacket</span>(packet, done);
  }
  done();
};

server.deleteOfflinePacket = function(client, messageId, cb) {
  that.deleteOfflinePacket(client, messageId, cb);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.storeRetained" id="apidoc.element.mosca.persistence.Redis.prototype.storeRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeRetained
        <span class="apidocSignatureSpan">(packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeRetained = function (packet, cb) {
  if (this._explicitlyClosed()) {
    return cb &#x26;&#x26; cb(new Error(&#x27;Explicitly closed&#x27;));
  }
  if (packet.payload.length &#x3e; 0) {
    this._client.hset(&#x22;retained&#x22;, packet.topic, JSON.stringify(packet), cb);
  } else {
    this._client.hdel(&#x22;retained&#x22;, packet.topic, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var done = function() {
    if (--total === 0 &#x26;&#x26; cb) {
      cb();
    }
  };
  if (packet.retain) {
    total++;
    that.<span class="apidocCodeKeywordSpan">storeRetained</span>(packet, done);
  }
  if (packet.qos !== 0 || that.options.storeMessagesQos0) {
    total++;
    that.storeOfflinePacket(packet, done);
  }
  done();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.storeSubscriptions" id="apidoc.element.mosca.persistence.Redis.prototype.storeSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeSubscriptions
        <span class="apidocSignatureSpan">(client, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeSubscriptions = function (client, cb) {
  if (this._explicitlyClosed()) {
    return cb &#x26;&#x26; cb(new Error(&#x27;Explicitly closed&#x27;));
  }
  if (client.clean) {
    return cb &#x26;&#x26; cb();
  }
  var clientSubKey = &#x22;client:sub:&#x22; + client.id;
  var that = this;
  var subscriptions = {};

  Object.keys(client.subscriptions).forEach(function(key) {
    if (client.subscriptions[key].qos &#x3e; 0) {
      subscriptions[key] = client.subscriptions[key];
    }
  });

  this._client.get(clientSubKey, function(err, currentSubs){
    var unsubs;
    if( !err &#x26;&#x26; currentSubs ) {
      currentSubs = JSON.parse(currentSubs);
      unsubs = Object.keys(currentSubs).filter(function (topic) {
        return !subscriptions[topic];
      });
      unsubs.forEach(function (topic) {
        that._subMatcher.remove(topic, client.id);
      });
    }
    var op = that._client.multi()
      .set(clientSubKey, JSON.stringify(subscriptions))
      .publish(that.options.channel, JSON.stringify({
        key: clientSubKey,
        subs: subscriptions,
        unsubs: unsubs,
        process: that._id
      }))
      .pexpire(clientSubKey, that.options.ttl.subscriptions);

    Object.keys(subscriptions).forEach(function(e) {
      that._subMatcher.add(e, client.id);
    });

    op.exec(cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     client.logger.debug({ packet: packet }, &#x22;Forwarding offline packet&#x22;);
     client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
   }, done);
 };

 server.persistClient = function(client, done) {
   client.logger.debug(&#x22;Storing offline subscriptions&#x22;);
   that.<span class="apidocCodeKeywordSpan">storeSubscriptions</span>(client, done);
 };
};

/**
* Close the persistance.
*
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.streamOfflinePackets" id="apidoc.element.mosca.persistence.Redis.prototype.streamOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>streamOfflinePackets
        <span class="apidocSignatureSpan">(client, cb, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamOfflinePackets = function (client, cb, done) {
  if (this._explicitlyClosed()) {
    return cb &#x26;&#x26; cb(new Error(&#x27;Explicitly closed&#x27;));
  }

  var that = this,
      listKey = &#x22;packets:&#x22; + client.id;

  that._client.lrange(listKey, 0, 10000, function(err, results) {

    var total = results.length;

    // for testing
    if(done &#x26;&#x26; total === 0)
      done();

    function emit(key, result) {
      if (result) {
        var match = key.match(keyRegexp);
        result = JSON.parse(result);
        result.payload = new Buffer(result.payload);
        result.messageId = match[3];

        cb(null, result);
      }
    }

    function fetch(multi, key) {
      return multi.get(key);
    }

    results.reduce(fetch, that._client.multi()).exec(function(err,multiResults){
      if(!multiResults &#x26;&#x26; done) {
        done(err);
        return;
      }
      multiResults.forEach(function(multiResult, i){
        var key = results[i];
        var result = multiResult[1];
        total --;
        // If we don&#x27;t get result for given packet key. It means
        // that packet has expired. Just clean it from client packets key
        if(!result) {
          that._client.lrem(listKey, 0, key);
          // for testing
          if(done &#x26;&#x26; total === 0)
            done();
          return;
        }
        emit(key, result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.forwardOfflinePackets = function(client, done) {
  // do not waste cpu time find in stored packets...
  // if client is clean lookupSubscriptions already delete stored packets
  if(client.clean)
    return done &#x26;&#x26; done();

  that.<span class="apidocCodeKeywordSpan">streamOfflinePackets</span>(client, function(err, packet) {
    packet.offline = true;
    client.logger.debug({ packet: packet }, &#x22;Forwarding offline packet&#x22;);
    client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
  }, done);
};

server.persistClient = function(client, done) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.updateOfflinePacket" id="apidoc.element.mosca.persistence.Redis.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, messageId, packet, done) {
  if (this._explicitlyClosed()) {
    return done &#x26;&#x26; done(new Error(&#x27;Explicitly closed&#x27;));
  }

  var that = this;
  var oldPacketKey = &#x22;packets:&#x22; + client.id + &#x22;:&#x22; + messageId;
  var newPacketKey = &#x22;packets:&#x22; + client.id + &#x22;:&#x22; + packet.messageId;
  var listKey = &#x22;packets:&#x22; + client.id;

  that._client.multi()
      .rename(oldPacketKey, newPacketKey)
      .lrem(listKey, 1, oldPacketKey)
      .rpush(listKey, newPacketKey)
      .pexpire(listKey, this._listKeyTTL)
      .exec(function(err) {
        done(err, packet);
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &#x26;&#x26; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.serializers" id="apidoc.module.mosca.serializers">module mosca.serializers</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.serializers.clientSerializer" id="apidoc.element.mosca.serializers.clientSerializer">
        function <span class="apidocSignatureSpan">mosca.serializers.</span>clientSerializer
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clientSerializer(client) {
  return client.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.serializers.packetSerializer" id="apidoc.element.mosca.serializers.packetSerializer">
        function <span class="apidocSignatureSpan">mosca.serializers.</span>packetSerializer
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packetSerializer(packet) {
  var result = {};

  if (packet.messageId) {
    result.messageId = packet.messageId;
  }

  if (packet.topic) {
    result.topic = packet.topic;
  }

  if (packet.qos) {
    result.qos = packet.qos;
  }

  if (packet.unsubscriptions) {
    result.unsubscriptions = packet.unsubscriptions;
  }

  if (packet.subscriptions) {
    result.subscriptions = packet.subscriptions;
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.utils" id="apidoc.module.mosca.utils">module mosca.utils</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.utils.topicPatterns" id="apidoc.element.mosca.utils.topicPatterns">
        function <span class="apidocSignatureSpan">mosca.utils.</span>topicPatterns
        <span class="apidocSignatureSpan">(topic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function topicPatterns(topic) {
  var result = cache.get(topic);
  if (!result) {
    result = _topicPatterns(topic);
  }
  cache.set(topic, result);
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
