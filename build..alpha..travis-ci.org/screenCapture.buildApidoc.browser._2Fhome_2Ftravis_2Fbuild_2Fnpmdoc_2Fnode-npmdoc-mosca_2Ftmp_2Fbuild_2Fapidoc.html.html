<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/mcollina/mosca#readme">mosca (v2.3.0)</a>
</h1>
<h4>MQTT broker as a module</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca">module mosca</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer">
            function <span class="apidocSignatureSpan">mosca.</span>Authorizer
            <span class="apidocSignatureSpan">(users)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server">
            function <span class="apidocSignatureSpan">mosca.</span>Server
            <span class="apidocSignatureSpan">(opts, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Stats">
            function <span class="apidocSignatureSpan">mosca.</span>Stats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client">
            function <span class="apidocSignatureSpan">mosca.</span>client
            <span class="apidocSignatureSpan">(conn, server)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.Memory
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.Mongo
            <span class="apidocSignatureSpan">(options, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis">
            function <span class="apidocSignatureSpan">mosca.</span>persistence.Redis
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>Authorizer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>Stats.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>interfaces</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.Memory.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.Mongo.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>persistence.Redis.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mosca.</span>serializers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Authorizer">module mosca.Authorizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.Authorizer">
            function <span class="apidocSignatureSpan">mosca.</span>Authorizer
            <span class="apidocSignatureSpan">(users)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Authorizer.prototype">module mosca.Authorizer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype._authenticate">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>_authenticate
            <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.addUser">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>addUser
            <span class="apidocSignatureSpan">(user, pass, authorizePublish, authorizeSubscribe, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.authenticate">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authenticate
            <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.authorizePublish">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizePublish
            <span class="apidocSignatureSpan">(client, topic, payload, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.authorizeSubscribe">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizeSubscribe
            <span class="apidocSignatureSpan">(client, topic, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Authorizer.prototype.rmUser">
            function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>rmUser
            <span class="apidocSignatureSpan">(user, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Server">module mosca.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.Server">
            function <span class="apidocSignatureSpan">mosca.</span>Server
            <span class="apidocSignatureSpan">(opts, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Server.prototype">module mosca.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.attachHttpServer">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>attachHttpServer
            <span class="apidocSignatureSpan">(server, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authenticate">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authenticate
            <span class="apidocSignatureSpan">(client, username, password, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authorizeForward">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeForward
            <span class="apidocSignatureSpan">(client, packet, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authorizePublish">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizePublish
            <span class="apidocSignatureSpan">(client, topic, payload, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.authorizeSubscribe">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeSubscribe
            <span class="apidocSignatureSpan">(client, topic, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.close">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.forwardOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardOfflinePackets
            <span class="apidocSignatureSpan">(client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.forwardRetained">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardRetained
            <span class="apidocSignatureSpan">(pattern, client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.generateUniqueId">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>generateUniqueId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.nextDedupId">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>nextDedupId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.persistClient">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>persistClient
            <span class="apidocSignatureSpan">(client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.publish">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>publish
            <span class="apidocSignatureSpan">(packet, client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.published">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>published
            <span class="apidocSignatureSpan">(packet, client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.restoreClientSubscriptions">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>restoreClientSubscriptions
            <span class="apidocSignatureSpan">(client, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.storePacket">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>storePacket
            <span class="apidocSignatureSpan">(packet, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.subscribe">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(topic, callback, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.toString">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Server.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, originMessageId, packet, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Stats">module mosca.Stats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Stats.Stats">
            function <span class="apidocSignatureSpan">mosca.</span>Stats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.Stats.prototype">module mosca.Stats.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.Stats.prototype.wire">
            function <span class="apidocSignatureSpan">mosca.Stats.prototype.</span>wire
            <span class="apidocSignatureSpan">(server)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.client">module mosca.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.client">
            function <span class="apidocSignatureSpan">mosca.</span>client
            <span class="apidocSignatureSpan">(conn, server)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.client.prototype">module mosca.client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype._buildForward">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_buildForward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype._setup">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.close">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>close
            <span class="apidocSignatureSpan">(callback, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleAuthorizePublish">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizePublish
            <span class="apidocSignatureSpan">(err, success, packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleAuthorizeSubscribe">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizeSubscribe
            <span class="apidocSignatureSpan">(err, success, s, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleConnect">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleConnect
            <span class="apidocSignatureSpan">(packet, completeConnection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handlePingreq">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePingreq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handlePuback">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePuback
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.handleSubscribe">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleSubscribe
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.onNonDisconnectClose">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>onNonDisconnectClose
            <span class="apidocSignatureSpan">(reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.setUpTimer">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>setUpTimer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.client.prototype.unsubscribeMapTo">
            function <span class="apidocSignatureSpan">mosca.client.prototype.</span>unsubscribeMapTo
            <span class="apidocSignatureSpan">(topic, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.interfaces">module mosca.interfaces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.buildServe">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildServe
            <span class="apidocSignatureSpan">(iface, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.buildWrap">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildWrap
            <span class="apidocSignatureSpan">(mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.httpFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.httpsFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpsFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.mqttFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.mqttsFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttsFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.interfaces.serverFactory">
            function <span class="apidocSignatureSpan">mosca.interfaces.</span>serverFactory
            <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.options">module mosca.options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.defaultsLegacy">
            function <span class="apidocSignatureSpan">mosca.options.</span>defaultsLegacy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.defaultsModern">
            function <span class="apidocSignatureSpan">mosca.options.</span>defaultsModern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.modernize">
            function <span class="apidocSignatureSpan">mosca.options.</span>modernize
            <span class="apidocSignatureSpan">(legacy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.populate">
            function <span class="apidocSignatureSpan">mosca.options.</span>populate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.options.validate">
            function <span class="apidocSignatureSpan">mosca.options.</span>validate
            <span class="apidocSignatureSpan">(opts, validationOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence">module mosca.persistence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
            <span class="apidocSignatureSpan">(options, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.getFactory">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>getFactory
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.LevelUp">module mosca.persistence.LevelUp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.LevelUp">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.LevelUp.prototype">module mosca.persistence.LevelUp.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype._cleanupStream">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_cleanupStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype._storePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_storePacket
            <span class="apidocSignatureSpan">(client, packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupRetained
            <span class="apidocSignatureSpan">(pattern, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeOfflinePacket
            <span class="apidocSignatureSpan">(packet, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeRetained
            <span class="apidocSignatureSpan">(packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.streamOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>streamOfflinePackets
            <span class="apidocSignatureSpan">(client, cb, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.LevelUp.super_.prototype">module mosca.persistence.LevelUp.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.wire">
            function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>wire
            <span class="apidocSignatureSpan">(server)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Memory">module mosca.persistence.Memory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory.Memory">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.Memory.</span>super_
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Memory.prototype">module mosca.persistence.Memory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Memory.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.Memory.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Mongo">module mosca.persistence.Mongo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.Mongo">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
            <span class="apidocSignatureSpan">(options, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Mongo.prototype">module mosca.persistence.Mongo.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype._storePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>_storePacket
            <span class="apidocSignatureSpan">(client, packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupRetained
            <span class="apidocSignatureSpan">(pattern, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.storeOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeOfflinePacket
            <span class="apidocSignatureSpan">(packet, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.storeRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeRetained
            <span class="apidocSignatureSpan">(packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.storeSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeSubscriptions
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.streamOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>streamOfflinePackets
            <span class="apidocSignatureSpan">(client, cb, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Mongo.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, packet, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Redis">module mosca.persistence.Redis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.Redis">
            function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.super_">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.persistence.Redis.prototype">module mosca.persistence.Redis.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._buildClient">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_buildClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._cleanClient">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_cleanClient
            <span class="apidocSignatureSpan">(client, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._explicitlyClosed">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_explicitlyClosed
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype._storePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_storePacket
            <span class="apidocSignatureSpan">(client, packet, pipeline, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.close">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>close
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.deleteOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>deleteOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.lookupRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupRetained
            <span class="apidocSignatureSpan">(pattern, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.lookupSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupSubscriptions
            <span class="apidocSignatureSpan">(client, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.storeOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeOfflinePacket
            <span class="apidocSignatureSpan">(packet, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.storeRetained">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeRetained
            <span class="apidocSignatureSpan">(packet, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.storeSubscriptions">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeSubscriptions
            <span class="apidocSignatureSpan">(client, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.streamOfflinePackets">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>streamOfflinePackets
            <span class="apidocSignatureSpan">(client, cb, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.persistence.Redis.prototype.updateOfflinePacket">
            function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>updateOfflinePacket
            <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mosca.serializers">module mosca.serializers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.serializers.clientSerializer">
            function <span class="apidocSignatureSpan">mosca.serializers.</span>clientSerializer
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mosca.serializers.packetSerializer">
            function <span class="apidocSignatureSpan">mosca.serializers.</span>packetSerializer
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca" id="apidoc.module.mosca">module mosca</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Authorizer" id="apidoc.element.mosca.Authorizer">
        function <span class="apidocSignatureSpan">mosca.</span>Authorizer
        <span class="apidocSignatureSpan">(users)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Authorizer(users) {
  this.users = users || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server" id="apidoc.element.mosca.Server">
        function <span class="apidocSignatureSpan">mosca.</span>Server
        <span class="apidocSignatureSpan">(opts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(opts, callback) {
  var modernOpts = options.modernize(opts);
  var validationResult = options.validate(modernOpts);

  if (validationResult.errors.length &gt; 0) {
    var errMessage = validationResult.errors[0].message;
    if (callback) {
      callback(new Error(errMessage));
    } else {
      throw new Error(errMessage);
    }
  }

  modernOpts = options.populate(modernOpts);

  if (!(this instanceof Server)) {
    return new Server(opts, callback);
  }

  EventEmitter.call(this);

  if (true) { // REFACTOR: kludge for tests that rely on options structure
    this.opts = extend(true, {}, defaults, opts);
    this.modernOpts = modernOpts;

    if (this.opts.secure) {
      this.opts.secure.port = this.opts.secure.port || 8883;
    }
    if (this.opts.http) {
      this.opts.http.port = this.opts.http.port || 3000;
    }
    if (this.opts.https) {
      this.opts.https.port = this.opts.https.port || 3001;
    }
  } else { // REFACTOR: enable this once test are updated
    this.opts = modernOpts;
  }

  callback = callback || function() {};

  this._dedupId = 0;
  this.clients = {};
  this.closed = false;

  if (this.modernOpts.logger.childOf) {
    this.logger = this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.name;
    this.logger = this.logger.child(this.modernOpts.logger);
  } else {
    this.logger = pino(this.modernOpts.logger);
  }

  if(this.modernOpts.stats) {
    new Stats().wire(this);
  }

  var that = this;

  // each Server has a dummy id for logging purposes
  this.id = this.modernOpts.id || shortid.generate();

  // initialize servers list
  this.servers = [];


  steed.series([

    // steed.series: wait for ascoltatore
    function (done) {

      if(that.modernOpts.ascoltatore) {
        that.ascoltatore = that.modernOpts.ascoltatore;
        done();
      }
      else {
        that.ascoltatore = ascoltatori.build(that.modernOpts.backend, done);
        that.ascoltatore.on('error', that.emit.bind(that, 'error'));
      }
    },

    // steed.series: wait for persistence

    function (done) {
      // REFACTOR: partially move to options.validate and options.populate?
      var persistenceFactory = that.modernOpts.persistence &amp;&amp; that.modernOpts.persistence.factory;
      if (persistenceFactory) {
        if (typeof persistenceFactory === 'string') {
          var factoryName = persistenceFactory;
          persistenceFactory = persistence.getFactory(factoryName);
          if (!persistenceFactory) {
            return callback(new Error('No persistence factory found for ' + factoryName ));
          }
        }

        that.persistence = persistenceFactory(that.modernOpts.persistence, done);
        that.persistence.wire(that);
      } else {
        that.persistence = null;
        done();
      }
    },

    // steed.series: iterate over defined interfaces, build servers and listen
    function (done) {

      steed.eachSeries(that.modernOpts.interfaces, function (iface, dn) {
        var fallback = that.modernOpts;
        var host = iface.host || that.modernOpts.host;
        var port = iface.port || that.modernOpts.port;

        var server = interfaces.serverFactory(iface, fallback, that);
        that.servers.push(server);
        server.maxConnections = iface.maxConnections || 10000000;
        server.listen(port, host, dn);
      }, done);
    },

    // steed.series: log startup information
    function (done) {
      var logInfo = {};

      that.modernOpts.interfaces.forEach(function (iface) {
        var name = iface.type;
        if (typeof name !== "string") {
          name = iface.type.name;
        }
        logInfo[name] = iface.port;
      });

      that.logger.info(logInfo, "server started");
      that.emit("ready");
      done(null);
    }
  ], function(err, results){
    if(err) {
      callback(err);
    }
  });

  that.on("clientConnected", function(client) {
    if(that.modernOpts.publishNewClient) {
      that.publish({
        topic: "$SYS/" + that.id + "/new/clients",
        payload: client.id ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var settings = {
  port: 1883,
  backend: ascoltatore
};

var server = new mosca.<span class="apidocCodeKeywordSpan">Server</span>(settings);

server.on('clientConnected', function(client) {
    console.log('client connected', client.id);
});

// fired when a message is received
server.on('published', function(packet, client) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Stats" id="apidoc.element.mosca.Stats">
        function <span class="apidocSignatureSpan">mosca.</span>Stats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats() {
  if (!(this instanceof Stats)) {
    return new Stats();
  }

  this.maxConnectedClients = 0;
  this.connectedClients = 0;
  this.lastIntervalConnectedClients = 0;
  this.publishedMessages = 0;
  this.lastIntervalPublishedMessages = 0;
  this.started = new Date();

  this.load = {
    m15: new Load(15),
    m5: new Load(5),
    m1: new Load(1)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client" id="apidoc.element.mosca.client">
        function <span class="apidocSignatureSpan">mosca.</span>client
        <span class="apidocSignatureSpan">(conn, server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(conn, server) {
  this.connection = conn;
  this.server = server;
  this.logger = server.logger;
  this.subscriptions = {};

  this.nextId = 1;
  this.inflight = {};
  this.inflightCounter = 0;
  this._lastDedupId = -1;
  this._closed = false;
  this._closing = false;

  this._setup();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp" id="apidoc.element.mosca.persistence.LevelUp">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.LevelUp
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel("retained");
  this._clientSubscriptions = db.sublevel("clientSubscriptions");
  this._subscriptions = db.sublevel("subscriptions");
  this._offlinePackets = db.sublevel("offlinePackets");
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on("data", function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on("end", function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on("close", function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory" id="apidoc.element.mosca.persistence.Memory">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.Memory
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryPersistence(options, callback) {
  if (!(this instanceof MemoryPersistence)) {
    return new MemoryPersistence(options, callback);
  }

  options = options || {};
  options.db = factory;
  options.path = "RAM";
  LevelUpPersistence.call(this, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo" id="apidoc.element.mosca.persistence.Mongo">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.Mongo
        <span class="apidocSignatureSpan">(options, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongoPersistence(options, done) {
  if (!(this instanceof MongoPersistence)) {
    return new MongoPersistence(options, done);
  }


  this.options = extend(true, {}, defaults, options);
  this.options.mongo.safe = true;

  // This offlineMessageTimeout(in milliseconds) can set the maximum life time for stored offline messages. This is a
  // Mongo-only feature which relies on TTL index. Since Mongo checks expired entries on a minute-based clock, the
  // actual lifetime is ceil(offlineMessageTimeout/60000) minutes. For this reason, we do not have an unit test
  // for this feature.
  if (options.offlineMessageTimeout) {
    this.options.ttl.packets = options.offlineMessageTimeout;
  }

  var that = this;

  var connected = function(err, db) {
    if (err) {
      if (done) {
        return done(err);
      }
      // we have no way of providing an error handler
      throw err;
    }

    that.db = db;
    steed.parallel([
      function(cb) {
        db.collection("subscriptions", function(err, coll) {
          that._subscriptions = coll;
          steed.parallel([
            that._subscriptions.ensureIndex.bind(that._subscriptions, "client"),
            that._subscriptions.ensureIndex.bind(that._subscriptions, { "added": 1 }, { expireAfterSeconds: Math.round(that.options
.ttl.subscriptions / 1000 )} )
          ], cb);
        });
      },
      function(cb) {
        db.collection("packets", function(err, coll) {
          if (err) {
            return cb(err);
          }

          that._packets = coll;
          steed.series([
            that._packets.ensureIndex.bind(that._packets, "client"),
            function(cb){
              // Check expiration indexes. If not exist, create; If exist but with different TTL, delete and recreate; Otherwise
, do nothing.
              that._packets.indexes(function(error, colIndexes){
                if (error) {
                  cb(error);
                } else {
                  var addedIndexKey = {"added": 1};
                  var addedIndexKeyString = 'added_1'; // If addedIndex changes, this value should also be changed accordingly.
                  var addedIndexObj = colIndexes.filter(function(obj){
                    return obj.name == addedIndexKeyString;
                  });
                  var packetTTLInSeconds = Math.round(that.options.ttl.packets / 1000);
                  if (addedIndexObj.length &lt;= 0 || addedIndexObj[0].expireAfterSeconds != packetTTLInSeconds) {
                    if (addedIndexObj.length &gt; 0) {
                      // Different index TTL, recreate index to make sure the TTL is set to the new number.
                      that._packets.dropIndex(addedIndexKeyString, function (error, result){
                        if (error) {
                          cb(error);
                        } else {
                          that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                        }
                      });
                    } else {
                      // Create Index for the first time.
                      that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                    }
                  } else {
                    cb(null);
                  }
                }
              });
            }
          ], cb);
        });
      },
      function(cb) {
        db.collection("retained", function(err, coll) {
          that._retained = coll;
          that._retained.ensureIndex("topic", { unique: true }, cb);
        });
      }
    ], function(err) {
      if (done) {
        done(err, that);
      }
    });
  };

  // Connect to the db
  if (options.connection) {
    connected(null, this.options.connection);
  } else {
    MongoClient.connect(this.options.url, this.options.mongo, connected);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis" id="apidoc.element.mosca.persistence.Redis">
        function <span class="apidocSignatureSpan">mosca.</span>persistence.Redis
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisPersistence(options, callback) {
  if (!(this instanceof RedisPersistence)) {
    return new RedisPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);

  this._subMatcher = new Matcher();

  this._client = this._buildClient();
  this._pubSubClient = this._buildClient();
  this._id = shortid.generate();

  this._packetKeyTTL = this.options.ttl.packets;
  this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key
  this._closing = false;
  this._closed = false;

  var fetchAndUpdateLocalSub = function(key, unsubs, retried, cb) {
    that._client.get(key, function(err, result) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          return;
        }
      }

      var subs = JSON.parse(result);
      if (!result || typeof subs !== 'object') {
        if (!retried) {
          setTimeout(fetchAndUpdateLocalSub.bind(null, key, unsubs, true, cb), 500);
        } else {
          cb &amp;&amp; cb();
        }
        return;
      }

      updateLocalSub(key, subs, unsubs);

      if (cb) {
        cb();
      }
    });
  };

  var updateLocalSub = function(key, subs, unsubs) {
    var xs = key.split(":");
    var id = key.substr(xs[0].length + xs[1].length + 2);

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.add(sub, id);
    });

    if( unsubs ) {
      unsubs.forEach(function(unsub) {
        that._subMatcher.remove(unsub, id);
      });
    }
  };

  var that = this;

  this._pubSubClient.subscribe(this.options.channel, function(){
    if (that._explicitlyClosed()) {
      return;
    }
    var subsStream = that._client.scanStream({
      match: "client:sub:*",
      count: 25000
    });
    var pipeline = that._client.pipeline();
    var total = 0;
    var done = null;

    subsStream.on('data', function(moreKeys){
      total += moreKeys.length;
      moreKeys.map(function(k){
        pipeline.get(k, function(err, result) {
          if (err) {
            done &amp;&amp; done(err);
            return;
          }
          var subs = JSON.parse(result);
          if (!result || typeof subs !== 'object') {
            done &amp;&amp; done();
            return;
          }
          updateLocalSub(k, subs);
          done &amp;&amp; done();
        });
      });
    });

    subsStream.on('end', function(){
      if (total === 0) {
        return callback(null, that);
      }
      done = function() {
        if (--total === 0 &amp;&amp; callback) {
          callback(null, that);
          callback = null;
        }
      };
      pipeline.exec();
    });
  });

  this._pubSubClient.on("message", function(channel, message) {
    if (that._explicitlyClosed()) {
      return;
    }
    var parsed = JSON.parse(message);
    if (parsed.process !== that._id) {
      updateLocalSub(parsed.key, parsed.subs, parsed.unsubs);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Authorizer" id="apidoc.module.mosca.Authorizer">module mosca.Authorizer</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Authorizer.Authorizer" id="apidoc.element.mosca.Authorizer.Authorizer">
        function <span class="apidocSignatureSpan">mosca.</span>Authorizer
        <span class="apidocSignatureSpan">(users)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Authorizer(users) {
  this.users = users || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Authorizer.prototype" id="apidoc.module.mosca.Authorizer.prototype">module mosca.Authorizer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype._authenticate" id="apidoc.element.mosca.Authorizer.prototype._authenticate">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>_authenticate
        <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_authenticate = function (client, user, pass, cb) {

  var missingUser = !user || !pass || !this.users[user];

  if (missingUser) {
    cb(null, false);
    return;
  }

  user = user.toString();

  client.user = user;
  user = this.users[user];

  hasher({
    password: pass.toString(),
    salt: user.salt
  }, function(err, pass, salt, hash) {
    if (err) {
      cb(err);
      return;
    }

    var success = (user.hash === hash);
    cb(null, success);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.addUser" id="apidoc.element.mosca.Authorizer.prototype.addUser">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>addUser
        <span class="apidocSignatureSpan">(user, pass, authorizePublish, authorizeSubscribe, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUser = function (user, pass, authorizePublish, authorizeSubscribe, cb) {
  var that = this;

  if (typeof authorizePublish === "function") {
    cb = authorizePublish;
    authorizePublish = null;
    authorizeSubscribe = null;
  } else if (typeof authorizeSubscribe == "function") {
    cb = authorizeSubscribe;
    authorizeSubscribe = null;
  }

  if (!authorizePublish) {
    authorizePublish = defaultGlob;
  }

  if (!authorizeSubscribe) {
    authorizeSubscribe = defaultGlob;
  }

  hasher({
    password: pass.toString()
  }, function(err, pass, salt, hash) {
    if (!err) {
      that.users[user] = {
        salt: salt,
        hash: hash,
        authorizePublish: authorizePublish,
        authorizeSubscribe: authorizeSubscribe
      };
    }
    cb(err);
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.authenticate" id="apidoc.element.mosca.Authorizer.prototype.authenticate">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authenticate
        <span class="apidocSignatureSpan">(client, user, pass, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authenticate = function (client, user, pass, cb) {
  that._authenticate(client, user, pass, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  client.stream.end();
  return;
}
  }


  that.server.<span class="apidocCodeKeywordSpan">authenticate</span>(this, packet.username, packet.password,
                       function(err, verdict) {

if (err) {
  logger.info({ username: packet.username }, "authentication error");
  client.connack({
    returnCode: 4
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.authorizePublish" id="apidoc.element.mosca.Authorizer.prototype.authorizePublish">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizePublish
        <span class="apidocSignatureSpan">(client, topic, payload, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizePublish = function (client, topic, payload, cb) {
  cb(null, minimatch(topic, that.users[client.user].authorizePublish || defaultGlob));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
client.on("subscribe", function(packet) {
  that.setUpTimer();
  that.handleSubscribe(packet);
});

client.on("publish", function(packet) {
  that.setUpTimer();
  that.server.<span class="apidocCodeKeywordSpan">authorizePublish</span>(that, packet.topic, packet.payload, function(err, success
) {
    that.handleAuthorizePublish(err, success, packet);
  });
});

client.on("unsubscribe", function(packet) {
  that.setUpTimer();
  that.logger.info({ packet: packet }, "unsubscribe received");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.authorizeSubscribe" id="apidoc.element.mosca.Authorizer.prototype.authorizeSubscribe">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>authorizeSubscribe
        <span class="apidocSignatureSpan">(client, topic, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizeSubscribe = function (client, topic, cb) {
  cb(null, minimatch(topic, that.users[client.user].authorizeSubscribe || defaultGlob));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};

function handleEachSub (s, cb) {
  /*jshint validthis:true */
  var that = this;
  if (this.subscriptions[s.topic] === undefined) {
    this.server.<span class="apidocCodeKeywordSpan">authorizeSubscribe</span>(that, s.topic, function(err, success) {
      that.handleAuthorizeSubscribe(err, success, s, cb);
    });
  } else {
    cb(null, true);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Authorizer.prototype.rmUser" id="apidoc.element.mosca.Authorizer.prototype.rmUser">
        function <span class="apidocSignatureSpan">mosca.Authorizer.prototype.</span>rmUser
        <span class="apidocSignatureSpan">(user, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmUser = function (user, cb) {
  delete this.users[user];
  cb();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Server" id="apidoc.module.mosca.Server">module mosca.Server</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Server.Server" id="apidoc.element.mosca.Server.Server">
        function <span class="apidocSignatureSpan">mosca.</span>Server
        <span class="apidocSignatureSpan">(opts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(opts, callback) {
  var modernOpts = options.modernize(opts);
  var validationResult = options.validate(modernOpts);

  if (validationResult.errors.length &gt; 0) {
    var errMessage = validationResult.errors[0].message;
    if (callback) {
      callback(new Error(errMessage));
    } else {
      throw new Error(errMessage);
    }
  }

  modernOpts = options.populate(modernOpts);

  if (!(this instanceof Server)) {
    return new Server(opts, callback);
  }

  EventEmitter.call(this);

  if (true) { // REFACTOR: kludge for tests that rely on options structure
    this.opts = extend(true, {}, defaults, opts);
    this.modernOpts = modernOpts;

    if (this.opts.secure) {
      this.opts.secure.port = this.opts.secure.port || 8883;
    }
    if (this.opts.http) {
      this.opts.http.port = this.opts.http.port || 3000;
    }
    if (this.opts.https) {
      this.opts.https.port = this.opts.https.port || 3001;
    }
  } else { // REFACTOR: enable this once test are updated
    this.opts = modernOpts;
  }

  callback = callback || function() {};

  this._dedupId = 0;
  this.clients = {};
  this.closed = false;

  if (this.modernOpts.logger.childOf) {
    this.logger = this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.childOf;
    delete this.modernOpts.logger.name;
    this.logger = this.logger.child(this.modernOpts.logger);
  } else {
    this.logger = pino(this.modernOpts.logger);
  }

  if(this.modernOpts.stats) {
    new Stats().wire(this);
  }

  var that = this;

  // each Server has a dummy id for logging purposes
  this.id = this.modernOpts.id || shortid.generate();

  // initialize servers list
  this.servers = [];


  steed.series([

    // steed.series: wait for ascoltatore
    function (done) {

      if(that.modernOpts.ascoltatore) {
        that.ascoltatore = that.modernOpts.ascoltatore;
        done();
      }
      else {
        that.ascoltatore = ascoltatori.build(that.modernOpts.backend, done);
        that.ascoltatore.on('error', that.emit.bind(that, 'error'));
      }
    },

    // steed.series: wait for persistence

    function (done) {
      // REFACTOR: partially move to options.validate and options.populate?
      var persistenceFactory = that.modernOpts.persistence &amp;&amp; that.modernOpts.persistence.factory;
      if (persistenceFactory) {
        if (typeof persistenceFactory === 'string') {
          var factoryName = persistenceFactory;
          persistenceFactory = persistence.getFactory(factoryName);
          if (!persistenceFactory) {
            return callback(new Error('No persistence factory found for ' + factoryName ));
          }
        }

        that.persistence = persistenceFactory(that.modernOpts.persistence, done);
        that.persistence.wire(that);
      } else {
        that.persistence = null;
        done();
      }
    },

    // steed.series: iterate over defined interfaces, build servers and listen
    function (done) {

      steed.eachSeries(that.modernOpts.interfaces, function (iface, dn) {
        var fallback = that.modernOpts;
        var host = iface.host || that.modernOpts.host;
        var port = iface.port || that.modernOpts.port;

        var server = interfaces.serverFactory(iface, fallback, that);
        that.servers.push(server);
        server.maxConnections = iface.maxConnections || 10000000;
        server.listen(port, host, dn);
      }, done);
    },

    // steed.series: log startup information
    function (done) {
      var logInfo = {};

      that.modernOpts.interfaces.forEach(function (iface) {
        var name = iface.type;
        if (typeof name !== "string") {
          name = iface.type.name;
        }
        logInfo[name] = iface.port;
      });

      that.logger.info(logInfo, "server started");
      that.emit("ready");
      done(null);
    }
  ], function(err, results){
    if(err) {
      callback(err);
    }
  });

  that.on("clientConnected", function(client) {
    if(that.modernOpts.publishNewClient) {
      that.publish({
        topic: "$SYS/" + that.id + "/new/clients",
        payload: client.id ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var settings = {
  port: 1883,
  backend: ascoltatore
};

var server = new mosca.<span class="apidocCodeKeywordSpan">Server</span>(settings);

server.on('clientConnected', function(client) {
    console.log('client connected', client.id);
});

// fired when a message is received
server.on('published', function(packet, client) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Server.prototype" id="apidoc.module.mosca.Server.prototype">module mosca.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.attachHttpServer" id="apidoc.element.mosca.Server.prototype.attachHttpServer">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>attachHttpServer
        <span class="apidocSignatureSpan">(server, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachHttpServer = function (server, path) {
  var that = this;

  var opt = { server: server };
  if (path) {
    opt.path = path;
  }

  ws.createServer(opt, function(stream) {
    var conn = new Connection(stream);
    new Client(conn, that);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return tls.createServer(credentials, buildWrap(mosca));
}

function httpFactory(iface, fallback, mosca) {
var serve = buildServe(iface, mosca);
var server = http.createServer(serve);

mosca.<span class="apidocCodeKeywordSpan">attachHttpServer</span>(server);
return server;
}

function httpsFactory(iface, fallback, mosca) {
var credentials = iface.credentials || fallback.credentials;
if (credentials === undefined) {
  throw new Error("missing credentials for https server");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authenticate" id="apidoc.element.mosca.Server.prototype.authenticate">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authenticate
        <span class="apidocSignatureSpan">(client, username, password, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authenticate = function (client, username, password, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  client.stream.end();
  return;
}
  }


  that.server.<span class="apidocCodeKeywordSpan">authenticate</span>(this, packet.username, packet.password,
                       function(err, verdict) {

if (err) {
  logger.info({ username: packet.username }, "authentication error");
  client.connack({
    returnCode: 4
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authorizeForward" id="apidoc.element.mosca.Server.prototype.authorizeForward">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeForward
        <span class="apidocSignatureSpan">(client, packet, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizeForward = function (client, packet, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var that = this;

  function doForward(err, packet) {
    if (err) {
return that.client &amp;&amp; that.client.emit('error', err);
    }

    that.server.<span class="apidocCodeKeywordSpan">authorizeForward</span>(that, packet, function(err, authorized) {
if (err) {
  return that.client &amp;&amp; that.client.emit('error', err);
}

if (!authorized) {
  that.logger.warn(packet, "Unauthorized Forward");
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authorizePublish" id="apidoc.element.mosca.Server.prototype.authorizePublish">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizePublish
        <span class="apidocSignatureSpan">(client, topic, payload, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizePublish = function (client, topic, payload, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
client.on("subscribe", function(packet) {
  that.setUpTimer();
  that.handleSubscribe(packet);
});

client.on("publish", function(packet) {
  that.setUpTimer();
  that.server.<span class="apidocCodeKeywordSpan">authorizePublish</span>(that, packet.topic, packet.payload, function(err, success
) {
    that.handleAuthorizePublish(err, success, packet);
  });
});

client.on("unsubscribe", function(packet) {
  that.setUpTimer();
  that.logger.info({ packet: packet }, "unsubscribe received");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.authorizeSubscribe" id="apidoc.element.mosca.Server.prototype.authorizeSubscribe">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>authorizeSubscribe
        <span class="apidocSignatureSpan">(client, topic, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizeSubscribe = function (client, topic, callback) {
  callback(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};

function handleEachSub (s, cb) {
  /*jshint validthis:true */
  var that = this;
  if (this.subscriptions[s.topic] === undefined) {
    this.server.<span class="apidocCodeKeywordSpan">authorizeSubscribe</span>(that, s.topic, function(err, success) {
      that.handleAuthorizeSubscribe(err, success, s, cb);
    });
  } else {
    cb(null, true);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.close" id="apidoc.element.mosca.Server.prototype.close">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  var that = this;
  var stuffToClose = [];

  callback = callback || function nop() {};

  if (that.closed) {
    return callback();
  }

  that.closed = true;

  Object.keys(that.clients).forEach(function(i) {
    stuffToClose.push(that.clients[i]);
  });

  that.servers.forEach(function(server) {
    stuffToClose.push(server);
  });

  if (that.persistence) {
    stuffToClose.push(that.persistence);
  }

  steed.each(stuffToClose, function(toClose, cb) {
    toClose.close(cb, "server closed");
  }, function() {
    that.ascoltatore.close(function () {
      that.logger.info("server closed");
      that.emit("closed");
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on("unsubscribe", function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, "unsubscribe received");
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.deleteOfflinePacket" id="apidoc.element.mosca.Server.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, "puback");
if (this.inflight[packet.messageId]) {
  this.server.emit("delivered", this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &amp;&amp; that.client.emit("error", err);
    }
    logger.debug({ packet: packet }, "cleaned offline packet");
  });
} else {
  logger.info({ packet: packet }, "no matching packet");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.forwardOfflinePackets" id="apidoc.element.mosca.Server.prototype.forwardOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardOfflinePackets
        <span class="apidocSignatureSpan">(client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forwardOfflinePackets = function (client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sessionPresent: session_present ? true : false
  });

  that.logger.info("client connected");
  that.server.emit("clientConnected", that);

  // packets will be forward only if client.clean is false
  that.server.<span class="apidocCodeKeywordSpan">forwardOfflinePackets</span>(that);
});

client.on("puback", function(packet) {
  that.setUpTimer();
  that.handlePuback(packet);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.forwardRetained" id="apidoc.element.mosca.Server.prototype.forwardRetained">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>forwardRetained
        <span class="apidocSignatureSpan">(pattern, client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forwardRetained = function (pattern, client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return;
}

that.server.persistClient(that);

packet.subscriptions.forEach(function(sub, index) {
  if (authorized[index]) {
    that.server.<span class="apidocCodeKeywordSpan">forwardRetained</span>(sub.topic, that);
    that.server.emit("subscribed", sub.topic, that);
  } else {
    granted[index] = 0x80;
  }
});

if(!that._closed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.generateUniqueId" id="apidoc.element.mosca.Server.prototype.generateUniqueId">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>generateUniqueId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateUniqueId = function () {
  return shortid.generate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.nextDedupId" id="apidoc.element.mosca.Server.prototype.nextDedupId">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>nextDedupId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextDedupId = function () {
  return this._dedupId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              indexPlus &gt;= 0 &amp;&amp;
              indexPlus &lt; 2
            )
          );

    if (forward) {
if (options._dedupId === undefined) {
  options._dedupId = that.server.<span class="apidocCodeKeywordSpan">nextDedupId</span>();
  that._lastDedupId = options._dedupId;
}

if (qos &amp;&amp; options.messageId) {
  that.server.updateOfflinePacket(that, options.messageId, packet, doForward);
} else {
  doForward(null, packet);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.persistClient" id="apidoc.element.mosca.Server.prototype.persistClient">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>persistClient
        <span class="apidocSignatureSpan">(client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persistClient = function (client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.logger.info({ packet: packet }, "unsubscribe received");
  steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
    if (err) {
      that.logger.warn(err);
      that.close(null, err.message);
      return;
    }
    that.server.<span class="apidocCodeKeywordSpan">persistClient</span>(that);
    client.unsuback({
      messageId: packet.messageId
    });
  });
});

client.on("disconnect", function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.publish" id="apidoc.element.mosca.Server.prototype.publish">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>publish
        <span class="apidocSignatureSpan">(packet, client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(packet, client, callback) {

  var that = this;
  var logger = this.logger;

  if (typeof client === 'function') {
    callback = client;
    client = null;
  } else if (client) {
    logger = client.logger;
  }

  if (!callback) {
    callback = nop;
  }

  var newPacket = {
    topic: packet.topic,
    payload: packet.payload,
    messageId: this.generateUniqueId(),
    qos: packet.qos,
    retain: packet.retain
  };

  var opts = {
    qos: packet.qos,
    messageId: newPacket.messageId
  };

  if (client) {
    opts.clientId = client.id;
  }

  that.storePacket(newPacket, function() {
    if (that.closed) {
      logger.debug({ packet: newPacket }, "not delivering because we are closed");
      return;
    }

    that.ascoltatore.publish(
      newPacket.topic,
      newPacket.payload,
      opts,
      function() {
        that.published(newPacket, client, function() {
          if( newPacket.topic.indexOf( '$SYS' ) &gt;= 0 ) {
            logger.trace({ packet: newPacket }, "published packet");
          } else {
            logger.debug({ packet: newPacket }, "published packet");
          }
          that.emit("published", newPacket, client);
          callback(undefined, newPacket);
        });
      }
    );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (!authorized) {
      that.logger.warn(packet, "Unauthorized Forward");
      return;
    }

    that.connection.<span class="apidocCodeKeywordSpan">publish</span>(packet);

    if (packet.qos === 1) {
      that.inflight[packet.messageId] = packet;
    }
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.published" id="apidoc.element.mosca.Server.prototype.published">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>published
        <span class="apidocSignatureSpan">(packet, client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">published = function (packet, client, callback) {
  callback(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.restoreClientSubscriptions" id="apidoc.element.mosca.Server.prototype.restoreClientSubscriptions">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>restoreClientSubscriptions
        <span class="apidocSignatureSpan">(client, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restoreClientSubscriptions = function (client, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._buildForward();

  client.on("error", nop);

  function completeConnection() {
that.setUpTimer();

that.server.<span class="apidocCodeKeywordSpan">restoreClientSubscriptions</span>(that, function(session_present) {
  client.connack({
    returnCode: 0,
    // maybe session_present is null, custom old persistence engine
    // or not persistence defined
    sessionPresent: session_present ? true : false
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.storePacket" id="apidoc.element.mosca.Server.prototype.storePacket">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>storePacket
        <span class="apidocSignatureSpan">(packet, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storePacket = function (packet, callback) {
  if (callback) {
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.subscribe" id="apidoc.element.mosca.Server.prototype.subscribe">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(topic, callback, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subscribe(topic, callback, done) {
  this.ascoltatore.subscribe(topic, callback, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var handler = function(topic, payload, options) {
  that.forward(topic, payload, options, s.topic, s.qos);
};

if (this.subscriptions[s.topic] === undefined) {
  this.subscriptions[s.topic] = { qos: s.qos, handler: handler };
  this.server.ascoltatore.<span class="apidocCodeKeywordSpan">subscribe</span>(
    s.topic,
    handler,
    function(err) {
      if (err) {
        delete that.subscriptions[s.topic];
        cb(err);
        return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.toString" id="apidoc.element.mosca.Server.prototype.toString">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return 'mosca.Server';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.Server.prototype.updateOfflinePacket" id="apidoc.element.mosca.Server.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.Server.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, originMessageId, packet, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, originMessageId, packet, callback) {
  if (callback) {
    callback(null, packet);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &amp;&amp; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Stats" id="apidoc.module.mosca.Stats">module mosca.Stats</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Stats.Stats" id="apidoc.element.mosca.Stats.Stats">
        function <span class="apidocSignatureSpan">mosca.</span>Stats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats() {
  if (!(this instanceof Stats)) {
    return new Stats();
  }

  this.maxConnectedClients = 0;
  this.connectedClients = 0;
  this.lastIntervalConnectedClients = 0;
  this.publishedMessages = 0;
  this.lastIntervalPublishedMessages = 0;
  this.started = new Date();

  this.load = {
    m15: new Load(15),
    m5: new Load(5),
    m1: new Load(1)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.Stats.prototype" id="apidoc.module.mosca.Stats.prototype">module mosca.Stats.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.Stats.prototype.wire" id="apidoc.element.mosca.Stats.prototype.wire">
        function <span class="apidocSignatureSpan">mosca.Stats.prototype.</span>wire
        <span class="apidocSignatureSpan">(server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wire(server) {
  server.stats = this;

  var count = 0;

  function doPublish(topic, value) {
    server.publish({
      topic: "$SYS/" + server.id + "/" + topic,
      payload: "" + value
    });
  }

  var mom = moment(this.started);

  var timer = setInterval(function() {
    var stats = server.stats;
    var mem = process.memoryUsage();

    var date = new Date();

    stats.load.m1.maConnectedClients.push(date, stats.lastIntervalConnectedClients);
    stats.load.m5.maConnectedClients.push(date, stats.lastIntervalConnectedClients);
    stats.load.m15.maConnectedClients.push(date, stats.lastIntervalConnectedClients);
    stats.lastIntervalConnectedClients = 0;

    stats.load.m1.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);
    stats.load.m5.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);
    stats.load.m15.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);
    stats.lastIntervalPublishedMessages = 0;

    doPublish("version", version);
    doPublish("started_at", server.stats.started.toISOString());
    doPublish("uptime", mom.from(Date.now(), true));
    doPublish("clients/maximum", stats.maxConnectedClients);
    doPublish("clients/connected", stats.connectedClients);
    doPublish("publish/received", stats.publishedMessages);
    doPublish("load/connections/15min", stats.load.m15.connectedClients);
    doPublish("load/publish/received/15min", stats.load.m15.publishedMessages);
    doPublish("load/connections/5min", stats.load.m5.connectedClients);
    doPublish("load/publish/received/5min", stats.load.m5.publishedMessages);
    doPublish("load/connections/1min", stats.load.m1.connectedClients);
    doPublish("load/publish/received/1min", stats.load.m1.publishedMessages);
    doPublish("memory/rss", mem.rss);
    doPublish("memory/heap/current", mem.heapUsed);
    doPublish("memory/heap/maximum", mem.heapTotal);
  }, 10 * 1000);

  events.forEach(function(event) {
    server.on(event.name, event);
  });

  server.once("closed", function() {
    clearInterval(timer);

    events.forEach(function(event) {
      server.removeListener(event.name, event);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.client" id="apidoc.module.mosca.client">module mosca.client</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.client.client" id="apidoc.element.mosca.client.client">
        function <span class="apidocSignatureSpan">mosca.</span>client
        <span class="apidocSignatureSpan">(conn, server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(conn, server) {
  this.connection = conn;
  this.server = server;
  this.logger = server.logger;
  this.subscriptions = {};

  this.nextId = 1;
  this.inflight = {};
  this.inflightCounter = 0;
  this._lastDedupId = -1;
  this._closed = false;
  this._closing = false;

  this._setup();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.client.prototype" id="apidoc.module.mosca.client.prototype">module mosca.client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.client.prototype._buildForward" id="apidoc.element.mosca.client.prototype._buildForward">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_buildForward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_buildForward = function () {
  var that = this;

  function doForward(err, packet) {
    if (err) {
      return that.client &amp;&amp; that.client.emit('error', err);
    }

    that.server.authorizeForward(that, packet, function(err, authorized) {
      if (err) {
        return that.client &amp;&amp; that.client.emit('error', err);
      }

      if (!authorized) {
        that.logger.warn(packet, "Unauthorized Forward");
        return;
      }

      that.connection.publish(packet);

      if (packet.qos === 1) {
        that.inflight[packet.messageId] = packet;
      }
    });
  }

  this.forward = function(topic, payload, options, subTopic, qos, cb) {
    if (options._dedupId &lt;= that._lastDedupId) {
      return;
    }

    that.logger.trace({ topic: topic }, "delivering message");

    var sub = that.subscriptions[subTopic],
        indexWildcard = subTopic.indexOf("#"),
        indexPlus = subTopic.indexOf("+"),
        forward = true,
        newId = this.nextId++;

    // Make sure 'nextId' always fits in a uint8 (http://git.io/vmgKI).
    this.nextId %= 65536;

    var packet = {
      topic: topic,
      payload: payload,
      qos: qos,
      messageId: newId
    };

    if (qos) {
      that.inflightCounter++;
    }

    if (that._closed || that._closing) {
      that.logger.debug({ packet: packet }, "trying to send a packet to a disconnected client");
      forward = false;
    } else if (that.inflightCounter &gt;= that.server.opts.maxInflightMessages) {
      that.logger.warn("too many inflight packets, closing");
      that.close(null, "too many inflight packets");
      forward = false;
    }

    if (cb) {
      cb();
    }

    // skip delivery of messages in $SYS for wildcards
    forward = forward &amp;&amp;
              ! ( topic.indexOf('$SYS') &gt;= 0 &amp;&amp;
                  (
                    indexWildcard &gt;= 0 &amp;&amp;
                    indexWildcard &lt; 2 ||
                    indexPlus &gt;= 0 &amp;&amp;
                    indexPlus &lt; 2
                  )
                );

    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &amp;&amp; options.messageId) {
        that.server.updateOfflinePacket(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up all the handlers, to not be called directly.
 *
 * @api private
 */
Client.prototype._setup = function() {
  var that = this, client = that.connection;

  this.<span class="apidocCodeKeywordSpan">_buildForward</span>();

  client.on("error", nop);

  function completeConnection() {
that.setUpTimer();

that.server.restoreClientSubscriptions(that, function(session_present) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype._setup" id="apidoc.element.mosca.client.prototype._setup">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>_setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setup = function () {
  var that = this, client = that.connection;

  this._buildForward();

  client.on("error", nop);

  function completeConnection() {
    that.setUpTimer();

    that.server.restoreClientSubscriptions(that, function(session_present) {
      client.connack({
        returnCode: 0,
        // maybe session_present is null, custom old persistence engine
        // or not persistence defined
        sessionPresent: session_present ? true : false
      });

      that.logger.info("client connected");
      that.server.emit("clientConnected", that);

      // packets will be forward only if client.clean is false
      that.server.forwardOfflinePackets(that);
    });

    client.on("puback", function(packet) {
      that.setUpTimer();
      that.handlePuback(packet);
    });

    client.on("pingreq", function() {
      that.logger.debug("pingreq");
      that.setUpTimer();
      that.handlePingreq();
      that.connection.pingresp();
    });

    client.on("subscribe", function(packet) {
      that.setUpTimer();
      that.handleSubscribe(packet);
    });

    client.on("publish", function(packet) {
      that.setUpTimer();
      that.server.authorizePublish(that, packet.topic, packet.payload, function(err, success) {
        that.handleAuthorizePublish(err, success, packet);
      });
    });

    client.on("unsubscribe", function(packet) {
      that.setUpTimer();
      that.logger.info({ packet: packet }, "unsubscribe received");
      steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
        if (err) {
          that.logger.warn(err);
          that.close(null, err.message);
          return;
        }
        that.server.persistClient(that);
        client.unsuback({
          messageId: packet.messageId
        });
      });
    });

    client.on("disconnect", function() {
      that.logger.debug("disconnect requested");
      that.close(null, "disconnect request");
    });

    function handleError(err) {
      that.logger.warn(err);
      that.onNonDisconnectClose(err.message);
    }

    client.on("error", handleError);
    client.removeListener("error", nop);

    client.on("close", function() {
      that.onNonDisconnectClose("close");
    });
  }

  client.once("connect", function(packet) {
    that.handleConnect(packet, completeConnection);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.nextId = 1;
 this.inflight = {};
 this.inflightCounter = 0;
 this._lastDedupId = -1;
 this._closed = false;
 this._closing = false;

 this.<span class="apidocCodeKeywordSpan">_setup</span>();
}

/**
* Sets up all the handlers, to not be called directly.
*
* @api private
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.close" id="apidoc.element.mosca.client.prototype.close">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>close
        <span class="apidocSignatureSpan">(callback, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback, reason) {

  callback = callback || nop;

  if (this._closed || this._closing) {
    return callback();
  }

  var that = this;

  if (this.id) {
    that.logger.debug("closing client, reason: " + reason);

    if (this.timer) {
      this.timer.clear();
    }
  }

  var cleanup = function() {
    that._closed = true;

    that.logger.info("closed");
    that.connection.removeAllListeners();
    // ignore all errors after disconnection
    that.connection.on("error", function() {});
    that.server.emit("clientDisconnected", that, reason);

    callback();
  };

  that._closing = true;

  steed.map(that, Object.keys(that.subscriptions), that.unsubscribeMapTo, function(err) {
    if (err) {
      that.logger.info(err);
    }

    // needed in case of errors
    if (!that._closed) {
      cleanup();
      // prefer destroy[Soon]() to prevent FIN_WAIT zombie connections
      if (that.connection.stream.destroySoon) {
        that.connection.stream.destroySoon();
      } else if (that.connection.stream.destroy) {
        that.connection.stream.destroy();
      } else {
        that.connection.stream.end();
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on("unsubscribe", function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, "unsubscribe received");
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleAuthorizePublish" id="apidoc.element.mosca.client.prototype.handleAuthorizePublish">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizePublish
        <span class="apidocSignatureSpan">(err, success, packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleAuthorizePublish = function (err, success, packet) {
  var that = this;

  if (err || !success) {
    if (!this._closed &amp;&amp; !this._closing) {
      that.close(null, (err &amp;&amp; err.message) || "publish not authorized");
    }
    return;
  }

  if (success instanceof Buffer) {
    packet.payload = success;
  }

  that.server.publish(packet, that, function() {
    if (packet.qos === 1 &amp;&amp; !(that._closed || that._closing)) {
      that.connection.puback({
        messageId: packet.messageId
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.setUpTimer();
  that.handleSubscribe(packet);
});

client.on("publish", function(packet) {
  that.setUpTimer();
  that.server.authorizePublish(that, packet.topic, packet.payload, function(err, success) {
    that.<span class="apidocCodeKeywordSpan">handleAuthorizePublish</span>(err, success, packet);
  });
});

client.on("unsubscribe", function(packet) {
  that.setUpTimer();
  that.logger.info({ packet: packet }, "unsubscribe received");
  steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleAuthorizeSubscribe" id="apidoc.element.mosca.client.prototype.handleAuthorizeSubscribe">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleAuthorizeSubscribe
        <span class="apidocSignatureSpan">(err, success, s, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleAuthorizeSubscribe = function (err, success, s, cb) {
  if (err) {
    cb(err);
    return;
  }

  if (!success) {
    this.logger.info({ topic: s.topic }, "subscribe not authorized");
    cb(null, false);
    return;
  }

  var that = this;

  var handler = function(topic, payload, options) {
    that.forward(topic, payload, options, s.topic, s.qos);
  };

  if (this.subscriptions[s.topic] === undefined) {
    this.subscriptions[s.topic] = { qos: s.qos, handler: handler };
    this.server.ascoltatore.subscribe(
      s.topic,
      handler,
      function(err) {
        if (err) {
          delete that.subscriptions[s.topic];
          cb(err);
          return;
        }
        that.logger.info({ topic: s.topic, qos: s.qos }, "subscribed to topic");
        //that.subscriptions[s.topic] = { qos: s.qos, handler: handler };
        cb(null, true);
      }
    );
  } else {
    cb(null, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

function handleEachSub (s, cb) {
  /*jshint validthis:true */
  var that = this;
  if (this.subscriptions[s.topic] === undefined) {
    this.server.authorizeSubscribe(that, s.topic, function(err, success) {
      that.<span class="apidocCodeKeywordSpan">handleAuthorizeSubscribe</span>(err, success, s, cb);
    });
  } else {
    cb(null, true);
  }
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleConnect" id="apidoc.element.mosca.client.prototype.handleConnect">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleConnect
        <span class="apidocSignatureSpan">(packet, completeConnection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleConnect = function (packet, completeConnection) {
  var that = this, logger, client = this.connection;

  this.id = packet.clientId;

  this.logger = logger = that.logger.child({ client: this });

  // for MQTT 3.1.1 (protocolVersion == 4) it is valid to receive an empty
  // clientId if cleanSession is set to 1. In this case, Mosca should generate
  // a random ID.
  // Otherwise, the connection should be rejected.
  if(!this.id) {

    if(packet.protocolVersion == 4 &amp;&amp; packet.clean) {

      this.id = uuid.v4();
    }
    else {

      logger.info("identifier rejected");
      client.connack({
        returnCode: 2
      });
      client.stream.end();
      return;
    }
  }


  that.server.authenticate(this, packet.username, packet.password,
                           function(err, verdict) {

    if (err) {
      logger.info({ username: packet.username }, "authentication error");
      client.connack({
        returnCode: 4
      });
      client.stream.end();
      return;
    }

    if (!verdict) {
      logger.info({ username: packet.username }, "authentication denied");
      client.connack({
        returnCode: 5
      });
      client.stream.end();
      return;
    }

    that.keepalive = packet.keepalive;
    that.will = packet.will;

    that.clean = packet.clean;

    if (that.id in that.server.clients){
      that.server.clients[that.id].close(completeConnection, "new connection request");
    } else {
      completeConnection();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   client.on("close", function() {
     that.onNonDisconnectClose("close");
   });
 }

 client.once("connect", function(packet) {
   that.<span class="apidocCodeKeywordSpan">handleConnect</span>(packet, completeConnection);
 });
};

/**
* Sets up the keepalive timer.
* To not be called directly.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handlePingreq" id="apidoc.element.mosca.client.prototype.handlePingreq">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePingreq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handlePingreq = function () {
  var that = this;
  that.server.emit("pingreq", that);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.setUpTimer();
  that.handlePuback(packet);
});

client.on("pingreq", function() {
  that.logger.debug("pingreq");
  that.setUpTimer();
  that.<span class="apidocCodeKeywordSpan">handlePingreq</span>();
  that.connection.pingresp();
});

client.on("subscribe", function(packet) {
  that.setUpTimer();
  that.handleSubscribe(packet);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handlePuback" id="apidoc.element.mosca.client.prototype.handlePuback">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handlePuback
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handlePuback = function (packet) {
  var logger = this.logger;
  var that = this;

  logger.debug({ packet: packet }, "puback");
  if (this.inflight[packet.messageId]) {
    this.server.emit("delivered", this.inflight[packet.messageId], that);
    this.inflightCounter--;
    delete this.inflight[packet.messageId];
    this.server.deleteOfflinePacket(this, packet.messageId, function(err) {
      if (err) {
        return that.client &amp;&amp; that.client.emit("error", err);
      }
      logger.debug({ packet: packet }, "cleaned offline packet");
    });
  } else {
    logger.info({ packet: packet }, "no matching packet");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // packets will be forward only if client.clean is false
  that.server.forwardOfflinePackets(that);
});

client.on("puback", function(packet) {
  that.setUpTimer();
  that.<span class="apidocCodeKeywordSpan">handlePuback</span>(packet);
});

client.on("pingreq", function() {
  that.logger.debug("pingreq");
  that.setUpTimer();
  that.handlePingreq();
  that.connection.pingresp();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.handleSubscribe" id="apidoc.element.mosca.client.prototype.handleSubscribe">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>handleSubscribe
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSubscribe = function (packet) {
  var that = this, server = this.server, logger = this.logger;

  logger.debug({ packet: packet }, "subscribe received");

  var granted = calculateGranted(this, packet);

  steed.map(this, packet.subscriptions, handleEachSub, function(err, authorized) {

    if (err) {
      that.close(null, err.message);
      return;
    }

    that.server.persistClient(that);

    packet.subscriptions.forEach(function(sub, index) {
      if (authorized[index]) {
        that.server.forwardRetained(sub.topic, that);
        that.server.emit("subscribed", sub.topic, that);
      } else {
        granted[index] = 0x80;
      }
    });

    if(!that._closed) {
      that.connection.suback({
        messageId: packet.messageId,
        granted: granted
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.setUpTimer();
  that.handlePingreq();
  that.connection.pingresp();
});

client.on("subscribe", function(packet) {
  that.setUpTimer();
  that.<span class="apidocCodeKeywordSpan">handleSubscribe</span>(packet);
});

client.on("publish", function(packet) {
  that.setUpTimer();
  that.server.authorizePublish(that, packet.topic, packet.payload, function(err, success) {
    that.handleAuthorizePublish(err, success, packet);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.onNonDisconnectClose" id="apidoc.element.mosca.client.prototype.onNonDisconnectClose">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>onNonDisconnectClose
        <span class="apidocSignatureSpan">(reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNonDisconnectClose = function (reason) {
  var that = this, logger = that.logger, will = that.will;

  if (this._closed || this._closing) {
    return;
  }

  if (that.will) {
    logger.info({ packet: will }, "delivering last will");
    setImmediate(function() {
      that.server.authorizePublish(that, will.topic, will.payload, function(err, success) {
        that.handleAuthorizePublish(err, success, will);
      });
    });
  }

  this.close(null, reason);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
client.on("disconnect", function() {
  that.logger.debug("disconnect requested");
  that.close(null, "disconnect request");
});

function handleError(err) {
  that.logger.warn(err);
  that.<span class="apidocCodeKeywordSpan">onNonDisconnectClose</span>(err.message);
}

client.on("error", handleError);
client.removeListener("error", nop);

client.on("close", function() {
  that.onNonDisconnectClose("close");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.setUpTimer" id="apidoc.element.mosca.client.prototype.setUpTimer">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>setUpTimer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setUpTimer = function () {
  if (this.keepalive &lt;= 0) {
    return;
  }

  var timeout = this.keepalive * 1000 * 3 / 2;
  var that = this;

  this.logger.debug({ timeout: timeout }, "setting keepalive timeout");

  if (this.timer) {
    this.timer.reschedule(timeout);
  } else {
    this.timer = retimer(function keepaliveTimeout() {
      that.logger.info("keepalive timeout");
      that.onNonDisconnectClose("keepalive timeout");
    }, timeout);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var that = this, client = that.connection;

  this._buildForward();

  client.on("error", nop);

  function completeConnection() {
that.<span class="apidocCodeKeywordSpan">setUpTimer</span>();

that.server.restoreClientSubscriptions(that, function(session_present) {
  client.connack({
    returnCode: 0,
    // maybe session_present is null, custom old persistence engine
    // or not persistence defined
    sessionPresent: session_present ? true : false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.client.prototype.unsubscribeMapTo" id="apidoc.element.mosca.client.prototype.unsubscribeMapTo">
        function <span class="apidocSignatureSpan">mosca.client.prototype.</span>unsubscribeMapTo
        <span class="apidocSignatureSpan">(topic, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribeMapTo = function (topic, cb) {
  var that = this;
  var sub = that.subscriptions[topic];
  if (!sub || !sub.handler) {
    that.server.emit("unsubscribed", topic, that);
    return cb();
  }

  that.server.ascoltatore.unsubscribe(topic, sub.handler, function(err) {
    if (err) {
      cb(err);
      return;
    }

    if (!that._closing || that.clean) {
      delete that.subscriptions[topic];
      that.logger.info({ topic: topic }, "unsubscribed");
      that.server.emit("unsubscribed", topic, that);
    }

    cb();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.interfaces" id="apidoc.module.mosca.interfaces">module mosca.interfaces</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.interfaces.buildServe" id="apidoc.element.mosca.interfaces.buildServe">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildServe
        <span class="apidocSignatureSpan">(iface, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildServe(iface, mosca) {
  var mounts = [];
  var logger = mosca.logger.child({ service: 'http bundle' });

  if (iface.bundle) {
    mounts.push(st({
      path: __dirname + "/../public",
      url: "/",
      dot: true,
      index: false,
      passthrough: true
    }));
  }

  if (iface.static) {
    mounts.push(st({
      path: iface.static,
      dot: true,
      url: "/",
      index: "index.html",
      passthrough: true
    }));
  }

  return function serve(req, res) {

    logger.info({ req: req });

    var cmounts = [].concat(mounts);

    res.on('finish', function() {
      logger.info({ res: res });
    });

    function handle() {
      var mount = cmounts.shift();

      if (mount) {
        mount(req, res, handle);
      } else {
        res.statusCode = 404;
        res.end("Not Found\n");
      }
    }

    handle();
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.buildWrap" id="apidoc.element.mosca.interfaces.buildWrap">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>buildWrap
        <span class="apidocSignatureSpan">(mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildWrap(mosca) {
  return function wrap(stream) {
    var connection = new Connection(stream);
    stream.setNoDelay(true);
    new Client(connection, mosca); // REFACTOR?
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.httpFactory" id="apidoc.element.mosca.interfaces.httpFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function httpFactory(iface, fallback, mosca) {
  var serve = buildServe(iface, mosca);
  var server = http.createServer(serve);

  mosca.attachHttpServer(server);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.httpsFactory" id="apidoc.element.mosca.interfaces.httpsFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>httpsFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function httpsFactory(iface, fallback, mosca) {
  var credentials = iface.credentials || fallback.credentials;
  if (credentials === undefined) {
    throw new Error("missing credentials for https server");
  }

  if (credentials.keyPath) {
    credentials.key = fs.readFileSync(credentials.keyPath);
  }

  if (credentials.certPath) {
    credentials.cert = fs.readFileSync(credentials.certPath);
  }

  if (credentials.caPaths) {
    credentials.ca = [];
    credentials.caPaths.forEach(function (caPath) {
    	credentials.ca.push(fs.readFileSync(caPath));
    });
  }

  var serve = buildServe(iface, mosca);
  var server = https.createServer(credentials, serve);
  mosca.attachHttpServer(server);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.mqttFactory" id="apidoc.element.mosca.interfaces.mqttFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mqttFactory(iface, fallback, mosca) {
  return net.createServer(buildWrap(mosca));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.mqttsFactory" id="apidoc.element.mosca.interfaces.mqttsFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>mqttsFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mqttsFactory(iface, fallback, mosca) {
  var credentials = iface.credentials || fallback.credentials;
  if (credentials === undefined) {
    throw new Error("missing credentials for mqtts server");
  }

  if (credentials.keyPath) {
    credentials.key = fs.readFileSync(credentials.keyPath);
  }

  if (credentials.certPath) {
    credentials.cert = fs.readFileSync(credentials.certPath);
  }

  if (credentials.caPaths) {
    credentials.ca = [];
    credentials.caPaths.forEach(function (caPath) {
    	credentials.ca.push(fs.readFileSync(caPath));
    });
  }

  return tls.createServer(credentials, buildWrap(mosca));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.interfaces.serverFactory" id="apidoc.element.mosca.interfaces.serverFactory">
        function <span class="apidocSignatureSpan">mosca.interfaces.</span>serverFactory
        <span class="apidocSignatureSpan">(iface, fallback, mosca)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serverFactory(iface, fallback, mosca) {
  var factories = {
    "mqtt":  mqttFactory,
    "mqtts": mqttsFactory,
    "http":  httpFactory,
    "https": httpsFactory,
  };

  var type = iface.type; // no fallback
  var factory = factories[type] || type;
  return factory(iface, fallback, mosca);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.options" id="apidoc.module.mosca.options">module mosca.options</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.options.defaultsLegacy" id="apidoc.element.mosca.options.defaultsLegacy">
        function <span class="apidocSignatureSpan">mosca.options.</span>defaultsLegacy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultsLegacy() {
  return {
    port: 1883,
    host: null,
    maxConnections: 10000000,
    backend: {
      json: false,
      wildcardOne: '+',
      wildcardSome: '#'
    },
    stats: false,
    publishNewClient: true,
    publishClientDisconnect: true,
    publishSubscriptions: true,
    maxInflightMessages: 1024,
    logger: {
      name: "mosca",
      level: "warn",
      serializers: {
        client: serializers.clientSerializer,
        packet: serializers.packetSerializer,
        req: pino.stdSerializers.req,
        res: pino.stdSerializers.res
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.defaultsModern" id="apidoc.element.mosca.options.defaultsModern">
        function <span class="apidocSignatureSpan">mosca.options.</span>defaultsModern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultsModern() {
  return {
    host: null,
    interfaces: [
      { type: "mqtt", port: 1883, maxConnections: 10000000 }
    ],
    backend: {
      json: false,
      wildcardOne: '+',
      wildcardSome: '#'
    },
    stats: false,
    publishNewClient: true,
    publishClientDisconnect: true,
    publishSubscriptions: true,
    maxInflightMessages: 1024,
    logger: {
      name: "mosca",
      level: "warn",
      serializers: {
        client: serializers.clientSerializer,
        packet: serializers.packetSerializer,
        req: pino.stdSerializers.req,
        res: pino.stdSerializers.res
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.modernize" id="apidoc.element.mosca.options.modernize">
        function <span class="apidocSignatureSpan">mosca.options.</span>modernize
        <span class="apidocSignatureSpan">(legacy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modernize(legacy) {

  legacy = legacy || {};

  var modernized = {};

  // "plain copyable" conserved options
  var conserved = [
    "id",
    "host",
    "maxInflightMessages",
    "stats",
    "publishNewClient",
    "publishClientDisconnect",
    "publishSubscriptions"
  ];

  // copy all conserved options
  conserved.forEach(function (name) {
    if (legacy.hasOwnProperty(name)) {
      modernized[name] = legacy[name];
    }
  });

  // TODO: copy `backend` carefully
  if (legacy.hasOwnProperty('backend')) {
    modernized.backend = legacy.backend;
  }

  // TODO: copy `ascoltatore` carefully
  if (legacy.hasOwnProperty('ascoltatore')) {
    modernized.ascoltatore = legacy.ascoltatore;
  }

  // TODO: copy `persistence` carefully
  if (legacy.hasOwnProperty('persistence')) {
    modernized.persistence = legacy.persistence;
  }

  // TODO: copy `logger` carefully
  if (legacy.hasOwnProperty('logger')) {
    modernized.logger = legacy.logger;
  }

  // construct `credentials`
  if (legacy.hasOwnProperty('credentials')) {
    // copy as is
    modernized.credentials = clone(legacy.credentials);
  } else if (legacy.hasOwnProperty('secure')) {
    // construct from `secure`
    modernized.credentials = {};
    if (legacy.secure.hasOwnProperty('keyPath')) {
      modernized.credentials.keyPath = legacy.secure.keyPath;
    }
    if (legacy.secure.hasOwnProperty('certPath')) {
      modernized.credentials.certPath = legacy.secure.certPath;
    }
  } // else no credentials were provided

  // construct `interfaces`
  if (legacy.hasOwnProperty('interfaces')) {
    // cloning
    modernized.interfaces = clone(legacy.interfaces);
  } else {
    // construct from legacy keys
    modernized.interfaces = [];

    // translate mqtt options
    var mqtt_enabled = !legacy.onlyHttp &amp;&amp; (typeof legacy.secure === 'undefined' || legacy.allowNonSecure);
    if (mqtt_enabled) {
      var mqtt_interface = { type: 'mqtt' };

      if (legacy.hasOwnProperty('port')) {
        mqtt_interface.port = legacy.port;
      }

      if (legacy.hasOwnProperty('maxConnections')) {
        mqtt_interface.maxConnections = legacy.maxConnections;
      }

      modernized.interfaces.push(mqtt_interface);
    }

    // translate mqtts options
    var mqtts_enabled = !legacy.onlyHttp &amp;&amp; legacy.secure;
    if (mqtts_enabled) {
      var mqtts_interface = { type: 'mqtts' };

      if (legacy.secure.hasOwnProperty('port')) {
        mqtts_interface.port = legacy.secure.port;
      }

      modernized.interfaces.push(mqtts_interface);
    }

    // translate http options
    var http_enabled = !!(legacy.http);
    if (http_enabled) {
      var http_interface = { type: 'http' };

      if (legacy.http.hasOwnProperty('port')) {
        http_interface.port = legacy.http.port;
      }

      if (legacy.http.hasOwnProperty('bundle')) {
        http_interface.bundle = legacy.http.bundle;
      }

      if (legacy.http.hasOwnProperty('static')) {
        http_interface.static = legacy.http.static;
      }

      modernized.interfaces.push(http_interface);
    }

    // translate https options
    var https_enabled = !!(legacy.https);
    if (https_enabled) {
      var https_interface = { type: 'https' };

      if (legacy.https.hasOwnProperty('port')) {
        https_interface.port = legacy.https.port;
      }

      if (legacy.https.hasOwnProperty('bundle')) {
        https_interface.bundle = legacy.https.bundle;
      }

      if (legacy.https.hasOwnProperty('static')) {
        https_interface.static = legacy.https.static;
      }

      modernized.interfaces.push(https_interface);
    }

    // NOTE: there are ways end up with no interfaces at all, for example
    // `httpOnly: true` with undefined http and https
  }

  return modernized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.populate" id="apidoc.element.mosca.options.populate">
        function <span class="apidocSignatureSpan">mosca.options.</span>populate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function populate(opts) {
  var defaults = defaultsModern();

  // do not extend `interfaces`
  if (opts.hasOwnProperty('interfaces')) {
    delete defaults.interfaces;
  }
  var populated = extend(true, defaults, opts);

  populated.interfaces.forEach(function (iface) {
    if (typeof iface.port === "undefined") {
      switch (iface.type) {
        case "mqtt":   iface.port = 1883; break;
        case "mqtts":  iface.port = 8883; break;
        case "http":   iface.port = 3000; break;
        case "https":  iface.port = 3001; break;
      }
    }
  });

  return populated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.options.validate" id="apidoc.element.mosca.options.validate">
        function <span class="apidocSignatureSpan">mosca.options.</span>validate
        <span class="apidocSignatureSpan">(opts, validationOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(opts, validationOptions) {
  var validator = new jsonschema.Validator();

  // custom function type
  validator.types.function = function testFunction(instance) {
    return instance instanceof Function;
  };

  validator.addSchema({
    id: '/Credentials',
    type: 'object',
    additionalProperties: true,
    properties: {
      'keyPath': { type: 'string', required: true },
      'certPath': { type: 'string', required: true },
      'caPaths': { type: 'array', required: false },
      'requestCert': { type: 'boolean', required: false },
      'rejectUnauthorized': { type: 'boolean', required: false }
    }
  });

  validator.addSchema({
    id: '/Interface',
    type: 'object',
    properties: {
      'type': { type: ['string', 'function'], required: true },
      'host': { type: ['string', 'null'] },
      'port': { type: ['integer'] },
      'credentials': { $ref: '/Credentials' },
    }
  });

  validator.addSchema({
    id: '/Options',
    type: 'object',
    additionalProperties: false,
    properties: {
      'id': { type: 'string' },
      'host': { type: ['string', 'null'] },
      'interfaces': {
        type: 'array',
        items: { $ref: '/Interface' }
      },
      'credentials': { $ref: '/Credentials' },

      'backend': { type: 'object' },     // TODO
      'ascoltatore': { type: 'object' }, // TODO
      'persistence': { type: 'object' }, // TODO
      'logger': { type: 'object' },      // TODO

      'maxInflightMessages': { type: 'integer' },
      'stats': { type: 'boolean' },
      'publishNewClient': { type: 'boolean' },
      'publishClientDisconnect': { type: 'boolean' },
      'publishSubscriptions': { type: 'boolean' }
    }
  });

  var result = validator.validate(opts, '/Options', validationOptions);

  // check required credentials
  if (opts.hasOwnProperty('interfaces')) {
    var hasCredentials = opts.hasOwnProperty('credentials');
    var reqCredentials = opts.interfaces.some(function (iface) {
      var req = (iface.type === 'mqtts' || iface.type === 'https');
      var has = iface.hasOwnProperty('credentials');
      return req &amp;&amp; !has;
    });

    if (reqCredentials &amp;&amp; !hasCredentials) {
      result.addError('one of the defiend interfaces requires credentials');
    }
  }

  // TODO: check conflicting backend and ascoltatore

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'stats': { type: 'boolean' },
    'publishNewClient': { type: 'boolean' },
    'publishClientDisconnect': { type: 'boolean' },
    'publishSubscriptions': { type: 'boolean' }
  }
});

var result = validator.<span class="apidocCodeKeywordSpan">validate</span>(opts, '/Options', validationOptions);

// check required credentials
if (opts.hasOwnProperty('interfaces')) {
  var hasCredentials = opts.hasOwnProperty('credentials');
  var reqCredentials = opts.interfaces.some(function (iface) {
    var req = (iface.type === 'mqtts' || iface.type === 'https');
    var has = iface.hasOwnProperty('credentials');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence" id="apidoc.module.mosca.persistence">module mosca.persistence</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp" id="apidoc.element.mosca.persistence.LevelUp">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel("retained");
  this._clientSubscriptions = db.sublevel("clientSubscriptions");
  this._subscriptions = db.sublevel("subscriptions");
  this._offlinePackets = db.sublevel("offlinePackets");
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on("data", function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on("end", function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on("close", function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory" id="apidoc.element.mosca.persistence.Memory">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryPersistence(options, callback) {
  if (!(this instanceof MemoryPersistence)) {
    return new MemoryPersistence(options, callback);
  }

  options = options || {};
  options.db = factory;
  options.path = "RAM";
  LevelUpPersistence.call(this, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo" id="apidoc.element.mosca.persistence.Mongo">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
        <span class="apidocSignatureSpan">(options, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongoPersistence(options, done) {
  if (!(this instanceof MongoPersistence)) {
    return new MongoPersistence(options, done);
  }


  this.options = extend(true, {}, defaults, options);
  this.options.mongo.safe = true;

  // This offlineMessageTimeout(in milliseconds) can set the maximum life time for stored offline messages. This is a
  // Mongo-only feature which relies on TTL index. Since Mongo checks expired entries on a minute-based clock, the
  // actual lifetime is ceil(offlineMessageTimeout/60000) minutes. For this reason, we do not have an unit test
  // for this feature.
  if (options.offlineMessageTimeout) {
    this.options.ttl.packets = options.offlineMessageTimeout;
  }

  var that = this;

  var connected = function(err, db) {
    if (err) {
      if (done) {
        return done(err);
      }
      // we have no way of providing an error handler
      throw err;
    }

    that.db = db;
    steed.parallel([
      function(cb) {
        db.collection("subscriptions", function(err, coll) {
          that._subscriptions = coll;
          steed.parallel([
            that._subscriptions.ensureIndex.bind(that._subscriptions, "client"),
            that._subscriptions.ensureIndex.bind(that._subscriptions, { "added": 1 }, { expireAfterSeconds: Math.round(that.options
.ttl.subscriptions / 1000 )} )
          ], cb);
        });
      },
      function(cb) {
        db.collection("packets", function(err, coll) {
          if (err) {
            return cb(err);
          }

          that._packets = coll;
          steed.series([
            that._packets.ensureIndex.bind(that._packets, "client"),
            function(cb){
              // Check expiration indexes. If not exist, create; If exist but with different TTL, delete and recreate; Otherwise
, do nothing.
              that._packets.indexes(function(error, colIndexes){
                if (error) {
                  cb(error);
                } else {
                  var addedIndexKey = {"added": 1};
                  var addedIndexKeyString = 'added_1'; // If addedIndex changes, this value should also be changed accordingly.
                  var addedIndexObj = colIndexes.filter(function(obj){
                    return obj.name == addedIndexKeyString;
                  });
                  var packetTTLInSeconds = Math.round(that.options.ttl.packets / 1000);
                  if (addedIndexObj.length &lt;= 0 || addedIndexObj[0].expireAfterSeconds != packetTTLInSeconds) {
                    if (addedIndexObj.length &gt; 0) {
                      // Different index TTL, recreate index to make sure the TTL is set to the new number.
                      that._packets.dropIndex(addedIndexKeyString, function (error, result){
                        if (error) {
                          cb(error);
                        } else {
                          that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                        }
                      });
                    } else {
                      // Create Index for the first time.
                      that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                    }
                  } else {
                    cb(null);
                  }
                }
              });
            }
          ], cb);
        });
      },
      function(cb) {
        db.collection("retained", function(err, coll) {
          that._retained = coll;
          that._retained.ensureIndex("topic", { unique: true }, cb);
        });
      }
    ], function(err) {
      if (done) {
        done(err, that);
      }
    });
  };

  // Connect to the db
  if (options.connection) {
    connected(null, this.options.connection);
  } else {
    MongoClient.connect(this.options.url, this.options.mongo, connected);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis" id="apidoc.element.mosca.persistence.Redis">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisPersistence(options, callback) {
  if (!(this instanceof RedisPersistence)) {
    return new RedisPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);

  this._subMatcher = new Matcher();

  this._client = this._buildClient();
  this._pubSubClient = this._buildClient();
  this._id = shortid.generate();

  this._packetKeyTTL = this.options.ttl.packets;
  this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key
  this._closing = false;
  this._closed = false;

  var fetchAndUpdateLocalSub = function(key, unsubs, retried, cb) {
    that._client.get(key, function(err, result) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          return;
        }
      }

      var subs = JSON.parse(result);
      if (!result || typeof subs !== 'object') {
        if (!retried) {
          setTimeout(fetchAndUpdateLocalSub.bind(null, key, unsubs, true, cb), 500);
        } else {
          cb &amp;&amp; cb();
        }
        return;
      }

      updateLocalSub(key, subs, unsubs);

      if (cb) {
        cb();
      }
    });
  };

  var updateLocalSub = function(key, subs, unsubs) {
    var xs = key.split(":");
    var id = key.substr(xs[0].length + xs[1].length + 2);

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.add(sub, id);
    });

    if( unsubs ) {
      unsubs.forEach(function(unsub) {
        that._subMatcher.remove(unsub, id);
      });
    }
  };

  var that = this;

  this._pubSubClient.subscribe(this.options.channel, function(){
    if (that._explicitlyClosed()) {
      return;
    }
    var subsStream = that._client.scanStream({
      match: "client:sub:*",
      count: 25000
    });
    var pipeline = that._client.pipeline();
    var total = 0;
    var done = null;

    subsStream.on('data', function(moreKeys){
      total += moreKeys.length;
      moreKeys.map(function(k){
        pipeline.get(k, function(err, result) {
          if (err) {
            done &amp;&amp; done(err);
            return;
          }
          var subs = JSON.parse(result);
          if (!result || typeof subs !== 'object') {
            done &amp;&amp; done();
            return;
          }
          updateLocalSub(k, subs);
          done &amp;&amp; done();
        });
      });
    });

    subsStream.on('end', function(){
      if (total === 0) {
        return callback(null, that);
      }
      done = function() {
        if (--total === 0 &amp;&amp; callback) {
          callback(null, that);
          callback = null;
        }
      };
      pipeline.exec();
    });
  });

  this._pubSubClient.on("message", function(channel, message) {
    if (that._explicitlyClosed()) {
      return;
    }
    var parsed = JSON.parse(message);
    if (parsed.process !== that._id) {
      updateLocalSub(parsed.key, parsed.subs, parsed.unsubs);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.getFactory" id="apidoc.element.mosca.persistence.getFactory">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>getFactory
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFactory = function (name) {
  return factories[name.toLowerCase()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.LevelUp" id="apidoc.module.mosca.persistence.LevelUp">module mosca.persistence.LevelUp</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.LevelUp" id="apidoc.element.mosca.persistence.LevelUp.LevelUp">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>LevelUp
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel("retained");
  this._clientSubscriptions = db.sublevel("clientSubscriptions");
  this._subscriptions = db.sublevel("subscriptions");
  this._offlinePackets = db.sublevel("offlinePackets");
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on("data", function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on("end", function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on("close", function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.super_" id="apidoc.element.mosca.persistence.LevelUp.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.LevelUp.prototype" id="apidoc.module.mosca.persistence.LevelUp.prototype">module mosca.persistence.LevelUp.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype._cleanupStream" id="apidoc.element.mosca.persistence.LevelUp.prototype._cleanupStream">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_cleanupStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanupStream = function (stream) {
  var index = this._streams.indexOf(stream);
  if (index !== -1) {
    this._streams.splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype._storePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype._storePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>_storePacket
        <span class="apidocSignatureSpan">(client, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_storePacket = function (client, packet, cb) {
  var currentTime = Date.now();
  if (currentTime !== this._lastStoredPacketTime) {
    this._packetCounter = 0;
  }
  this._lastStoredPacketTime = currentTime;
  var key = util.format("%s:%d:%d", client, currentTime, ++this._packetCounter);
  packet.ttl = this.options.ttl.packets + currentTime;
  this._offlinePackets.put(key, packet, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.close" id="apidoc.element.mosca.persistence.LevelUp.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this._streams.forEach(function(stream) {
    stream.destroy();
  });
  this.db.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on("unsubscribe", function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, "unsubscribe received");
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.deleteOfflinePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, done) {
  var that = this;
  var prefix = util.format('%s:', client.id);
  var found = false;
  var stream = that._offlinePackets.createReadStream({
    start : prefix,
    end : prefix + '~'
  });
  this._streams.push(stream);

  stream.on("data", function(data) {
    if (data.value.messageId !== messageId) {
      return;
    }

    found = true;

    that._offlinePackets.del(data.key, function() {
      if (done) {
        done();
      }
    });
  });

  stream.on("end", function() {
    that._cleanupStream(stream);
  });

  stream.on("close", function() {
    that._cleanupStream(stream);
  });

  if (done) {
    stream.on("error", done);
    stream.on("end", function() {
      if (!found) {
        done();
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, "puback");
if (this.inflight[packet.messageId]) {
  this.server.emit("delivered", this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &amp;&amp; that.client.emit("error", err);
    }
    logger.debug({ packet: packet }, "cleaned offline packet");
  });
} else {
  logger.info({ packet: packet }, "no matching packet");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupRetained" id="apidoc.element.mosca.persistence.LevelUp.prototype.lookupRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupRetained
        <span class="apidocSignatureSpan">(pattern, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupRetained = function (pattern, cb) {
  var that = this;
  var matched = [];
  var matcher = new Matcher();
  var stream = this._retained.createReadStream();
  this._streams.push(stream);
  matcher.add(pattern, true);

  stream.on("error", cb);

  stream.on("end", function() {
    that._cleanupStream(stream);
    cb(null, matched);
  });

  stream.on("close", function() {
    that._cleanupStream(stream);
  });

  stream.on("data", function(data) {
    if (matcher.match(data.key).size &gt; 0) {
      matched.push(data.value);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.lookupSubscriptions" id="apidoc.element.mosca.persistence.LevelUp.prototype.lookupSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>lookupSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupSubscriptions = function (client, done) {
  var that = this;
  this._clientSubscriptions.get(client.id, function(err, subscriptions) {
    var toRemove = [];

    subscriptions = subscriptions || {};

    Object.keys(subscriptions).forEach(function(key) {
      var levelKey = util.format("%s:%s", key, client.id);
      if (subscriptions[key].ttl &lt;= Date.now()) {
        delete subscriptions[key];
        that._subMatcher.remove(key, levelKey);
        toRemove.push(levelKey);
      }
    });

    if (client.clean) {
      that._clientSubscriptions.del(client.id, function() {
        Object.keys(subscriptions).forEach(function(key) {
          // TODO we need to remove these from the subMatcher every time.
          var levelKey = util.format("%s:%s", key, client.id);
          that._subMatcher.remove(key, levelKey);
          toRemove.push(levelKey);
        });

        that.streamOfflinePackets(client, nop, function() {
          that._subscriptions.batch(toRemove.map(function(levelKey) {
            return {
              key: levelKey,
              type: 'del'
            };
          }), function(err) {
            done(err, {});
          });
        });
      });
    } else if (done) {
      done(null, subscriptions);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeOfflinePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype.storeOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeOfflinePacket
        <span class="apidocSignatureSpan">(packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeOfflinePacket = function (packet, done) {
  var that = this;
  var subs = this._subMatcher.match(packet.topic);
  steed.map(from(subs), function(key, cb) {
    that._subscriptions.get(key, function(err, sub) {
      if (err) {
        return cb(err);
      }
      that._storePacket(sub.client, packet, cb);
    });
  }, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeRetained" id="apidoc.element.mosca.persistence.LevelUp.prototype.storeRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeRetained
        <span class="apidocSignatureSpan">(packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeRetained = function (packet, cb) {
  if (packet.payload.length &gt; 0) {
    this._retained.put(packet.topic, packet, cb);
  } else {
    this._retained.del(packet.topic, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.storeSubscriptions" id="apidoc.element.mosca.persistence.LevelUp.prototype.storeSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>storeSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeSubscriptions = function (client, done) {
  var that = this;
  var subscriptions = {};
  var now = Date.now();

  if (!client.clean) {
    Object.keys(client.subscriptions).forEach(function(key) {
      if (client.subscriptions[key].qos &gt; 0) {
        subscriptions[key] = client.subscriptions[key];
        subscriptions[key].ttl = that.options.ttl.subscriptions + now;
      }
    });
    this._clientSubscriptions.put(client.id, subscriptions, done);
    Object.keys(subscriptions).forEach(function(key) {
      var sub = {
        client: client.id,
        topic: key,
        ttl: that.options.ttl.subscriptions + now,
        qos: subscriptions[key].qos
      };
      var levelKey = util.format("%s:%s", key, client.id);
      that._subMatcher.add(key, levelKey);
      that._subscriptions.put(levelKey, sub);
    });
  } else if (done) {
    done();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.streamOfflinePackets" id="apidoc.element.mosca.persistence.LevelUp.prototype.streamOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>streamOfflinePackets
        <span class="apidocSignatureSpan">(client, cb, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamOfflinePackets = function (client, cb, done) {
  var that = this;
  var prefix = util.format('%s:', client.id);
  var count = 0;
  var ended = false;
  var stream = that._offlinePackets.createReadStream({
    start : prefix,
    end : prefix + '~'
  });
  this._streams.push(stream);

  stream.on("data", function(data) {

    if (client.clean || data.value.ttl &lt;= Date.now()) {
      count++;
      that._offlinePackets.del(data.key, function() {
        count--;

	// for testing
        if (ended &amp;&amp; count === 0 &amp;&amp; done) {
          done();
        }
      });
    } else {
      cb(null, data.value);
    }
  });

  stream.on("end", function() {
    that._cleanupStream(stream);
    ended = true;

    // for testing
    if (count === 0 &amp;&amp; done) {
      done();
    }
  });

  stream.on("close", function() {
    that._cleanupStream(stream);
  });

  // for testing
  if (done) {
    stream.on("error", done);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.prototype.updateOfflinePacket" id="apidoc.element.mosca.persistence.LevelUp.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, messageId, packet, done) {
  var that = this;
  var prefix = util.format('%s:', client.id);
  var found = false;
  var stream = that._offlinePackets.createReadStream({
    start : prefix,
    end : prefix + '~'
  });
  this._streams.push(stream);

  stream.on("data", function(data) {
    if (data.value.messageId !== messageId) {
      return;
    }

    found = true;

    data.value.messageId = packet.messageId;

    that._offlinePackets.put(data.key, data.value, function() {
      if (done) {
        done(null, packet);
      }
    });
  });

  stream.on("end", function() {
    that._cleanupStream(stream);
  });

  stream.on("close", function() {
    that._cleanupStream(stream);
  });

  if (done) {
    stream.on("error", done);
    stream.on("end", function() {
      if (!found) {
        done(null, packet);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &amp;&amp; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.LevelUp.super_.prototype" id="apidoc.module.mosca.persistence.LevelUp.super_.prototype">module mosca.persistence.LevelUp.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.close" id="apidoc.element.mosca.persistence.LevelUp.super_.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (done) {
  if (done) {
    done(new Error("not implemented yet"));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on("unsubscribe", function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, "unsubscribe received");
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.LevelUp.super_.prototype.wire" id="apidoc.element.mosca.persistence.LevelUp.super_.prototype.wire">
        function <span class="apidocSignatureSpan">mosca.persistence.LevelUp.super_.prototype.</span>wire
        <span class="apidocSignatureSpan">(server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wire = function (server) {
  var that = this;
  var nop = function() {};
  server.persistence = this;

  server.storePacket = function(packet, cb) {

    // store qos 0 packets only if storeMessagesQos0 is true or retain is true
    if(packet.qos === 0 &amp;&amp; packet.retain === false &amp;&amp; ! that.options.storeMessagesQos0){
      return cb();
    }

    var total = 1;
    var done = function() {
      if (--total === 0 &amp;&amp; cb) {
        cb();
      }
    };
    if (packet.retain) {
      total++;
      that.storeRetained(packet, done);
    }
    if (packet.qos !== 0 || that.options.storeMessagesQos0) {
      total++;
      that.storeOfflinePacket(packet, done);
    }
    done();
  };

  server.deleteOfflinePacket = function(client, messageId, cb) {
    that.deleteOfflinePacket(client, messageId, cb);
  };

  server.updateOfflinePacket = function(client, messageId, packet, cb) {
    that.updateOfflinePacket(client, messageId, packet, cb);
  };

  server.forwardRetained = function(pattern, client, done) {
    that.lookupRetained(pattern, function(err, matches) {
      if (err) {
        client.connection.emit("error", err);
        return;
      }
      steed.each(matches, function(match, cb) {
        client.forward(match.topic, match.payload, match, pattern, match.qos, cb);
      }, done);
    });
  };

  server.on("close", function() {
    that.close();
  });

  server.restoreClientSubscriptions = function restoreClientSubscriptions(client, done) {
    that.lookupSubscriptions(client, function(err, subscriptions) {
      if (err) {
        client.connection.emit("error", err);
        return;
      }

      var subs = Object.keys(subscriptions);

      steed.each(subs, function(topic, inCb) {
        client.logger.debug({ topic: topic, qos: subscriptions[topic].qos }, "restoring subscription");
        client.handleAuthorizeSubscribe(
          null, true, {
          topic: topic,
          qos: subscriptions[topic].qos
        }, inCb);
      }, function(){done(subs.length === 0 ? false : true);});
    });
  };

  server.forwardOfflinePackets = function(client, done) {
    // do not waste cpu time find in stored packets...
    // if client is clean lookupSubscriptions already delete stored packets
    if(client.clean)
      return done &amp;&amp; done();

    that.streamOfflinePackets(client, function(err, packet) {
      packet.offline = true;
      client.logger.debug({ packet: packet }, "Forwarding offline packet");
      client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);
    }, done);
  };

  server.persistClient = function(client, done) {
    client.logger.debug("Storing offline subscriptions");
    that.storeSubscriptions(client, done);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Memory" id="apidoc.module.mosca.persistence.Memory">module mosca.persistence.Memory</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory.Memory" id="apidoc.element.mosca.persistence.Memory.Memory">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Memory
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryPersistence(options, callback) {
  if (!(this instanceof MemoryPersistence)) {
    return new MemoryPersistence(options, callback);
  }

  options = options || {};
  options.db = factory;
  options.path = "RAM";
  LevelUpPersistence.call(this, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory.super_" id="apidoc.element.mosca.persistence.Memory.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.Memory.</span>super_
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelUpPersistence(options, callback) {
  if (!(this instanceof LevelUpPersistence)) {
    return new LevelUpPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);


  this.db = levelup(this.options.path, this.options);

  var db = sublevel(this.db);

  this._retained = db.sublevel("retained");
  this._clientSubscriptions = db.sublevel("clientSubscriptions");
  this._subscriptions = db.sublevel("subscriptions");
  this._offlinePackets = db.sublevel("offlinePackets");
  this._subMatcher = new Matcher();
  this._packetCounter = 0;
  this._lastStoredPacketTime = Date.now();
  this._streams = [];

  var that = this;
  var stream = this._subscriptions.createReadStream();
  this._streams.push(stream);
  stream.on("data", function(data) {
    that._subMatcher.add(data.value.topic, data.key);
  });
  stream.on("end", function() {
    that._cleanupStream(stream);
    if (callback) {
      callback(null, that);
    }
  });
  stream.on("close", function() {
    that._cleanupStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Memory.prototype" id="apidoc.module.mosca.persistence.Memory.prototype">module mosca.persistence.Memory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Memory.prototype.close" id="apidoc.element.mosca.persistence.Memory.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.Memory.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {

  MemDOWN.clearGlobalStore();

  this._streams.forEach(function(stream) {
    stream.destroy();
  });
  this.db.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on("unsubscribe", function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, "unsubscribe received");
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Mongo" id="apidoc.module.mosca.persistence.Mongo">module mosca.persistence.Mongo</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.Mongo" id="apidoc.element.mosca.persistence.Mongo.Mongo">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Mongo
        <span class="apidocSignatureSpan">(options, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongoPersistence(options, done) {
  if (!(this instanceof MongoPersistence)) {
    return new MongoPersistence(options, done);
  }


  this.options = extend(true, {}, defaults, options);
  this.options.mongo.safe = true;

  // This offlineMessageTimeout(in milliseconds) can set the maximum life time for stored offline messages. This is a
  // Mongo-only feature which relies on TTL index. Since Mongo checks expired entries on a minute-based clock, the
  // actual lifetime is ceil(offlineMessageTimeout/60000) minutes. For this reason, we do not have an unit test
  // for this feature.
  if (options.offlineMessageTimeout) {
    this.options.ttl.packets = options.offlineMessageTimeout;
  }

  var that = this;

  var connected = function(err, db) {
    if (err) {
      if (done) {
        return done(err);
      }
      // we have no way of providing an error handler
      throw err;
    }

    that.db = db;
    steed.parallel([
      function(cb) {
        db.collection("subscriptions", function(err, coll) {
          that._subscriptions = coll;
          steed.parallel([
            that._subscriptions.ensureIndex.bind(that._subscriptions, "client"),
            that._subscriptions.ensureIndex.bind(that._subscriptions, { "added": 1 }, { expireAfterSeconds: Math.round(that.options
.ttl.subscriptions / 1000 )} )
          ], cb);
        });
      },
      function(cb) {
        db.collection("packets", function(err, coll) {
          if (err) {
            return cb(err);
          }

          that._packets = coll;
          steed.series([
            that._packets.ensureIndex.bind(that._packets, "client"),
            function(cb){
              // Check expiration indexes. If not exist, create; If exist but with different TTL, delete and recreate; Otherwise
, do nothing.
              that._packets.indexes(function(error, colIndexes){
                if (error) {
                  cb(error);
                } else {
                  var addedIndexKey = {"added": 1};
                  var addedIndexKeyString = 'added_1'; // If addedIndex changes, this value should also be changed accordingly.
                  var addedIndexObj = colIndexes.filter(function(obj){
                    return obj.name == addedIndexKeyString;
                  });
                  var packetTTLInSeconds = Math.round(that.options.ttl.packets / 1000);
                  if (addedIndexObj.length &lt;= 0 || addedIndexObj[0].expireAfterSeconds != packetTTLInSeconds) {
                    if (addedIndexObj.length &gt; 0) {
                      // Different index TTL, recreate index to make sure the TTL is set to the new number.
                      that._packets.dropIndex(addedIndexKeyString, function (error, result){
                        if (error) {
                          cb(error);
                        } else {
                          that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                        }
                      });
                    } else {
                      // Create Index for the first time.
                      that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);
                    }
                  } else {
                    cb(null);
                  }
                }
              });
            }
          ], cb);
        });
      },
      function(cb) {
        db.collection("retained", function(err, coll) {
          that._retained = coll;
          that._retained.ensureIndex("topic", { unique: true }, cb);
        });
      }
    ], function(err) {
      if (done) {
        done(err, that);
      }
    });
  };

  // Connect to the db
  if (options.connection) {
    connected(null, this.options.connection);
  } else {
    MongoClient.connect(this.options.url, this.options.mongo, connected);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.super_" id="apidoc.element.mosca.persistence.Mongo.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Mongo.prototype" id="apidoc.module.mosca.persistence.Mongo.prototype">module mosca.persistence.Mongo.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype._storePacket" id="apidoc.element.mosca.persistence.Mongo.prototype._storePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>_storePacket
        <span class="apidocSignatureSpan">(client, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_storePacket = function (client, packet, cb) {
  var toStore = {
    client: client,
    packet: packet,
    added: new Date()
  };

  this._packets.insert(toStore, {w:1}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.close" id="apidoc.element.mosca.persistence.Mongo.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  if (this.db &amp;&amp; this.options.autoClose !== false) {
    this.db.close(cb);
  } else {
    cb();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on("unsubscribe", function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, "unsubscribe received");
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.deleteOfflinePacket" id="apidoc.element.mosca.persistence.Mongo.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, cb) {
  var toSearch = {
    client: client.id,
    'packet.messageId': messageId
  };

  this._packets.remove(toSearch, {w:1}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, "puback");
if (this.inflight[packet.messageId]) {
  this.server.emit("delivered", this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &amp;&amp; that.client.emit("error", err);
    }
    logger.debug({ packet: packet }, "cleaned offline packet");
  });
} else {
  logger.info({ packet: packet }, "no matching packet");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupRetained" id="apidoc.element.mosca.persistence.Mongo.prototype.lookupRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupRetained
        <span class="apidocSignatureSpan">(pattern, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupRetained = function (pattern, cb) {
  var regexp = new RegExp(pattern.replace(/(#|\+)/, ".+").replace('\\', '\\\\'));
  var stream = this._retained.find({ topic: { $regex: regexp } }).stream();
  var matched = [];
  var matcher = new Matcher();
  matcher.add(pattern, true);

  stream.on("error", cb);

  stream.on("end", function() {
    cb(null, matched);
  });

  stream.on("data", function(data) {
    if (matcher.match(data.topic).size &gt; 0) {
      data.payload = data.payload.buffer;
      matched.push(data);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.lookupSubscriptions" id="apidoc.element.mosca.persistence.Mongo.prototype.lookupSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>lookupSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupSubscriptions = function (client, done) {
  var that = this;
  this._subscriptions.find({ client: client.id })
                     .toArray(function(err, subscriptions) {

    var now = Date.now();

    subscriptions = (subscriptions || []).reduce(function(obj, sub) {
      // mongodb TTL is not precise
      if (sub.added.getTime() + that.options.ttl.subscriptions &gt; now) {
        obj[sub.topic] = {
          qos: sub.qos
        };
      }
      return obj;
    }, {});

    if (!client.clean) {
      done(err, subscriptions);
      return;
    }

    var toExecute = [
      function removeSubscriptions(cb) {
        that._subscriptions.remove({ client: client.id }, cb);
      },
      function removePackets(cb) {
        that._packets.remove({ client: client.id }, cb);
      }
    ];

    steed.parallel(toExecute, function(err) {
      done(null, {});
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.storeOfflinePacket" id="apidoc.element.mosca.persistence.Mongo.prototype.storeOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeOfflinePacket
        <span class="apidocSignatureSpan">(packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeOfflinePacket = function (packet, done) {

  var patterns = topicPatterns(packet.topic);

  var stream = this._subscriptions.find({ topic: { $in: patterns } }).stream();
  var ended = false;
  var completed = 0;
  var started = 0;
  var that = this;

  if (done) {
    stream.on("error", done);
  }

  stream.on("data", function(data) {
    started++;

    that._storePacket(data.client, packet, function(err) {
      if (err) {
        return stream.emit("error", err);
      }

      // TODO handle the err in case of no callback
      completed++;

      if (done &amp;&amp; ended &amp;&amp; started === completed) {
        done();
      }
    });
  });

  stream.on("end", function() {
    ended = true;
    if (done &amp;&amp; started === completed) {
      done();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.storeRetained" id="apidoc.element.mosca.persistence.Mongo.prototype.storeRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeRetained
        <span class="apidocSignatureSpan">(packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeRetained = function (packet, cb) {
  if (packet.payload.length &gt; 0) {
    this._retained.update(
      { topic: packet.topic },
      packet,
      {
        upsert: true,
        w: 1
      },
      function(err, n, result){
        if(cb) {
          return cb(err);
        }
      });
  } else {
    this._retained.remove(
      { topic: packet.topic },
      { w: 1 },
      cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.storeSubscriptions" id="apidoc.element.mosca.persistence.Mongo.prototype.storeSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>storeSubscriptions
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeSubscriptions = function (client, done) {

  var subscriptions;
  var that = this;

  if (!client.clean) {
    subscriptions = Object.keys(client.subscriptions).filter(function(key) {
      return client.subscriptions[key].qos &gt; 0;
    });

    steed.each(subscriptions, function(key, cb) {
      that._subscriptions.findAndModify({
        client: client.id,
        topic: key
      }, [['date', -1]], {
        $set: {
          client: client.id,
          topic: key,
          qos: client.subscriptions[key].qos,
          added: new Date()
        }
      }, { upsert: true}, cb);
    }, done);
  } else if (done) {
    return done();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.streamOfflinePackets" id="apidoc.element.mosca.persistence.Mongo.prototype.streamOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>streamOfflinePackets
        <span class="apidocSignatureSpan">(client, cb, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamOfflinePackets = function (client, cb, done) {

  var stream = this._packets.find({ client: client.id }).stream();
  var that = this;

  var now = Date.now();

  // for testing
  if(done)
    stream.on("end", done);

  stream.on("error", cb);

  stream.on("data", function(data) {
    // mongodb TTL is not precise
    // mongodb automaticly remove the packet
    if (data.added.getTime() + that.options.ttl.packets &gt; now) {
      data.packet.payload = data.packet.payload.buffer;
      cb(null, data.packet);
    }
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Mongo.prototype.updateOfflinePacket" id="apidoc.element.mosca.persistence.Mongo.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Mongo.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, messageId, packet, cb) {
  this._packets.update({
    client: client.id,
    'packet.messageId': messageId
  }, {
    $set: { 'packet.messageId': packet.messageId }
  }, {w:1}, function(err) {
    cb(err, packet);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &amp;&amp; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Redis" id="apidoc.module.mosca.persistence.Redis">module mosca.persistence.Redis</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.Redis" id="apidoc.element.mosca.persistence.Redis.Redis">
        function <span class="apidocSignatureSpan">mosca.persistence.</span>Redis
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisPersistence(options, callback) {
  if (!(this instanceof RedisPersistence)) {
    return new RedisPersistence(options, callback);
  }

  this.options = extend(true, {}, defaults, options);

  this._subMatcher = new Matcher();

  this._client = this._buildClient();
  this._pubSubClient = this._buildClient();
  this._id = shortid.generate();

  this._packetKeyTTL = this.options.ttl.packets;
  this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key
  this._closing = false;
  this._closed = false;

  var fetchAndUpdateLocalSub = function(key, unsubs, retried, cb) {
    that._client.get(key, function(err, result) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          return;
        }
      }

      var subs = JSON.parse(result);
      if (!result || typeof subs !== 'object') {
        if (!retried) {
          setTimeout(fetchAndUpdateLocalSub.bind(null, key, unsubs, true, cb), 500);
        } else {
          cb &amp;&amp; cb();
        }
        return;
      }

      updateLocalSub(key, subs, unsubs);

      if (cb) {
        cb();
      }
    });
  };

  var updateLocalSub = function(key, subs, unsubs) {
    var xs = key.split(":");
    var id = key.substr(xs[0].length + xs[1].length + 2);

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.add(sub, id);
    });

    if( unsubs ) {
      unsubs.forEach(function(unsub) {
        that._subMatcher.remove(unsub, id);
      });
    }
  };

  var that = this;

  this._pubSubClient.subscribe(this.options.channel, function(){
    if (that._explicitlyClosed()) {
      return;
    }
    var subsStream = that._client.scanStream({
      match: "client:sub:*",
      count: 25000
    });
    var pipeline = that._client.pipeline();
    var total = 0;
    var done = null;

    subsStream.on('data', function(moreKeys){
      total += moreKeys.length;
      moreKeys.map(function(k){
        pipeline.get(k, function(err, result) {
          if (err) {
            done &amp;&amp; done(err);
            return;
          }
          var subs = JSON.parse(result);
          if (!result || typeof subs !== 'object') {
            done &amp;&amp; done();
            return;
          }
          updateLocalSub(k, subs);
          done &amp;&amp; done();
        });
      });
    });

    subsStream.on('end', function(){
      if (total === 0) {
        return callback(null, that);
      }
      done = function() {
        if (--total === 0 &amp;&amp; callback) {
          callback(null, that);
          callback = null;
        }
      };
      pipeline.exec();
    });
  });

  this._pubSubClient.on("message", function(channel, message) {
    if (that._explicitlyClosed()) {
      return;
    }
    var parsed = JSON.parse(message);
    if (parsed.process !== that._id) {
      updateLocalSub(parsed.key, parsed.subs, parsed.unsubs);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.super_" id="apidoc.element.mosca.persistence.Redis.super_">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractPersistence() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.persistence.Redis.prototype" id="apidoc.module.mosca.persistence.Redis.prototype">module mosca.persistence.Redis.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._buildClient" id="apidoc.element.mosca.persistence.Redis.prototype._buildClient">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_buildClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_buildClient = function () {
  var options = this.options.redisOptions || {};

  if (this.options.url) {
    options.url = this.options.url;
  }

  if (this.options.host) {
    options.host = this.options.host;
  }

  if (this.options.port) {
    options.port = this.options.port;
  }

  if (this.options.db) {
    options.db = this.options.db;
  }

  if (this.options.password) {
    options.password = this.options.password;
  }

  return new Redis(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._cleanClient" id="apidoc.element.mosca.persistence.Redis.prototype._cleanClient">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_cleanClient
        <span class="apidocSignatureSpan">(client, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanClient = function (client, done) {
  var that = this;

  var key = "client:sub:" + client.id;

  this._client.get(key, function(err, subs) {
    subs = JSON.parse(subs) || {};

    Object.keys(subs).forEach(function(sub) {
      that._subMatcher.remove(sub, client.id);
    });

    steed.parallel([
      function(cb) {
        that._client.del(key, cb);
      },
      function(cb) {
        that._client.del("packets:" + client.id, cb);
      }
    ], function(err) {
      if (done) {
        done(err, {});
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._explicitlyClosed" id="apidoc.element.mosca.persistence.Redis.prototype._explicitlyClosed">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_explicitlyClosed
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_explicitlyClosed = function (done) {
  return this._closing || this._closed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype._storePacket" id="apidoc.element.mosca.persistence.Redis.prototype._storePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>_storePacket
        <span class="apidocSignatureSpan">(client, packet, pipeline, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_storePacket = function (client, packet, pipeline, cb) {
  if (this._explicitlyClosed()) {
    return cb &amp;&amp; cb(new Error('Explicitly closed'));
  }

  var packetKey = "packets:" + client + ":" + packet.messageId,
      listKey = "packets:" + client;

  pipeline.multi()
    .set(packetKey, JSON.stringify(packet))
    .pexpire(packetKey, this._packetKeyTTL)
    .rpush(listKey, packetKey)
    .pexpire(listKey, this._listKeyTTL)
    .exec();

  cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.close" id="apidoc.element.mosca.persistence.Redis.prototype.close">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>close
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (done) {
  if (this._closed) {
    return done &amp;&amp; done();
  }
  if (this._closing) {
    return done &amp;&amp; this.once('close', done);
  }
  this._closing = true;

  var that = this;

  steed.each([
    "_client", "_pubSubClient"
  ], function(client, cb) {
    if (that[client]) {
      that[client].quit(function quit(err) {
        delete that[client];
        cb(err);
      });
    } else {
      cb();
    }
  }, function() {
    that._closed = true;
    that.emit('close');
    done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    client.on("unsubscribe", function(packet) {
that.setUpTimer();
that.logger.info({ packet: packet }, "unsubscribe received");
steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {
  if (err) {
    that.logger.warn(err);
    that.<span class="apidocCodeKeywordSpan">close</span>(null, err.message);
    return;
  }
  that.server.persistClient(that);
  client.unsuback({
    messageId: packet.messageId
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.deleteOfflinePacket" id="apidoc.element.mosca.persistence.Redis.prototype.deleteOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>deleteOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOfflinePacket = function (client, messageId, done) {
  if (this._explicitlyClosed()) {
    return done &amp;&amp; done(new Error('Explicitly closed'));
  }

  var that = this;
  var packetKey = "packets:" + client.id + ":" + messageId;

  this._client.multi()
    .del(packetKey)
    .lrem("packets:" + client.id, 1, packetKey)
    .exec(done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var that = this;

logger.debug({ packet: packet }, "puback");
if (this.inflight[packet.messageId]) {
  this.server.emit("delivered", this.inflight[packet.messageId], that);
  this.inflightCounter--;
  delete this.inflight[packet.messageId];
  this.server.<span class="apidocCodeKeywordSpan">deleteOfflinePacket</span>(this, packet.messageId, function(err) {
    if (err) {
      return that.client &amp;&amp; that.client.emit("error", err);
    }
    logger.debug({ packet: packet }, "cleaned offline packet");
  });
} else {
  logger.info({ packet: packet }, "no matching packet");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.lookupRetained" id="apidoc.element.mosca.persistence.Redis.prototype.lookupRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupRetained
        <span class="apidocSignatureSpan">(pattern, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupRetained = function (pattern, done) {
  if (this._explicitlyClosed()) {
    return done &amp;&amp; done(new Error('Explicitly closed'));
  }
  var that = this;
  var matched = [];
  var match = function(topic, cb) {
    that._client.hget("retained", topic, function(err, packet) {
      if (packet) {

        packet = JSON.parse(packet);
        packet.payload = new Buffer(packet.payload);

        matched.push(packet);
      }

      cb(err, matched);
    });
  };

  if (pattern.indexOf("#") &gt;= 0 || pattern.indexOf("+") &gt;= 0) {
    var matcher = new Matcher();
    matcher.add(pattern, true);

    this._client.hkeys("retained", function(err, topics) {
      topics.sort();
      topics = topics.filter(function(topic) {
        return matcher.match(topic).size &gt; 0;
      });

      steed.each(topics, match, function(err) {
        done(err, matched);
      });
    });

    // do something
  } else {
    match(pattern, done);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.lookupSubscriptions" id="apidoc.element.mosca.persistence.Redis.prototype.lookupSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>lookupSubscriptions
        <span class="apidocSignatureSpan">(client, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupSubscriptions = function (client, cb) {
  if (this._explicitlyClosed()) {
    return cb &amp;&amp; cb(new Error('Explicitly closed'));
  }

  if (client.clean) {
    this._cleanClient(client, cb);
  }else{
    var key = "client:sub:" + client.id;
    var subscriptions;

    var multi = this._client.multi();

    multi.get(key);

    multi.exec(function(err, result) {
      subscriptions = JSON.parse(result[0][1]) || {};
      cb(err, subscriptions);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.storeOfflinePacket" id="apidoc.element.mosca.persistence.Redis.prototype.storeOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeOfflinePacket
        <span class="apidocSignatureSpan">(packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeOfflinePacket = function (packet, done) {
  if (this._explicitlyClosed()) {
    return done &amp;&amp; done(new Error('Explicitly closed'));
  }

  var that = this;

  var matches = this._subMatcher.match(packet.topic);
  var pipeline = this._client.pipeline();
  steed.each(from(matches), function(client, cb) {
    that._storePacket(client, packet, pipeline, cb);
  }, function(){
    pipeline.exec(done);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.storeRetained" id="apidoc.element.mosca.persistence.Redis.prototype.storeRetained">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeRetained
        <span class="apidocSignatureSpan">(packet, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeRetained = function (packet, cb) {
  if (this._explicitlyClosed()) {
    return cb &amp;&amp; cb(new Error('Explicitly closed'));
  }
  if (packet.payload.length &gt; 0) {
    this._client.hset("retained", packet.topic, JSON.stringify(packet), cb);
  } else {
    this._client.hdel("retained", packet.topic, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.storeSubscriptions" id="apidoc.element.mosca.persistence.Redis.prototype.storeSubscriptions">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>storeSubscriptions
        <span class="apidocSignatureSpan">(client, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeSubscriptions = function (client, cb) {
  if (this._explicitlyClosed()) {
    return cb &amp;&amp; cb(new Error('Explicitly closed'));
  }
  if (client.clean) {
    return cb &amp;&amp; cb();
  }
  var clientSubKey = "client:sub:" + client.id;
  var that = this;
  var subscriptions = {};

  Object.keys(client.subscriptions).forEach(function(key) {
    if (client.subscriptions[key].qos &gt; 0) {
      subscriptions[key] = client.subscriptions[key];
    }
  });

  this._client.get(clientSubKey, function(err, currentSubs){
    var unsubs;
    if( !err &amp;&amp; currentSubs ) {
      currentSubs = JSON.parse(currentSubs);
      unsubs = Object.keys(currentSubs).filter(function (topic) {
        return !subscriptions[topic];
      });
      unsubs.forEach(function (topic) {
        that._subMatcher.remove(topic, client.id);
      });
    }
    var op = that._client.multi()
      .set(clientSubKey, JSON.stringify(subscriptions))
      .publish(that.options.channel, JSON.stringify({
        key: clientSubKey,
        subs: subscriptions,
        unsubs: unsubs,
        process: that._id
      }))
      .pexpire(clientSubKey, that.options.ttl.subscriptions);

    Object.keys(subscriptions).forEach(function(e) {
      that._subMatcher.add(e, client.id);
    });

    op.exec(cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.streamOfflinePackets" id="apidoc.element.mosca.persistence.Redis.prototype.streamOfflinePackets">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>streamOfflinePackets
        <span class="apidocSignatureSpan">(client, cb, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamOfflinePackets = function (client, cb, done) {
  if (this._explicitlyClosed()) {
    return cb &amp;&amp; cb(new Error('Explicitly closed'));
  }

  var that = this,
      listKey = "packets:" + client.id;

  that._client.lrange(listKey, 0, 10000, function(err, results) {

    var total = results.length;

    // for testing
    if(done &amp;&amp; total === 0)
      done();

    function emit(key, result) {
      if (result) {
        var match = key.match(keyRegexp);
        result = JSON.parse(result);
        result.payload = new Buffer(result.payload);
        result.messageId = match[3];

        cb(null, result);
      }
    }

    function fetch(multi, key) {
      return multi.get(key);
    }

    results.reduce(fetch, that._client.multi()).exec(function(err,multiResults){
      if(!multiResults &amp;&amp; done) {
        done(err);
        return;
      }
      multiResults.forEach(function(multiResult, i){
        var key = results[i];
        var result = multiResult[1];
        total --;
        // If we don't get result for given packet key. It means
        // that packet has expired. Just clean it from client packets key
        if(!result) {
          that._client.lrem(listKey, 0, key);
          // for testing
          if(done &amp;&amp; total === 0)
            done();
          return;
        }
        emit(key, result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.persistence.Redis.prototype.updateOfflinePacket" id="apidoc.element.mosca.persistence.Redis.prototype.updateOfflinePacket">
        function <span class="apidocSignatureSpan">mosca.persistence.Redis.prototype.</span>updateOfflinePacket
        <span class="apidocSignatureSpan">(client, messageId, packet, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOfflinePacket = function (client, messageId, packet, done) {
  if (this._explicitlyClosed()) {
    return done &amp;&amp; done(new Error('Explicitly closed'));
  }

  var that = this;
  var oldPacketKey = "packets:" + client.id + ":" + messageId;
  var newPacketKey = "packets:" + client.id + ":" + packet.messageId;
  var listKey = "packets:" + client.id;

  that._client.multi()
      .rename(oldPacketKey, newPacketKey)
      .lrem(listKey, 1, oldPacketKey)
      .rpush(listKey, newPacketKey)
      .pexpire(listKey, this._listKeyTTL)
      .exec(function(err) {
        done(err, packet);
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (forward) {
      if (options._dedupId === undefined) {
        options._dedupId = that.server.nextDedupId();
        that._lastDedupId = options._dedupId;
      }

      if (qos &amp;&amp; options.messageId) {
        that.server.<span class="apidocCodeKeywordSpan">updateOfflinePacket</span>(that, options.messageId, packet, doForward);
      } else {
        doForward(null, packet);
      }
    }
  };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mosca.serializers" id="apidoc.module.mosca.serializers">module mosca.serializers</a></h1>


    <h2>
        <a href="#apidoc.element.mosca.serializers.clientSerializer" id="apidoc.element.mosca.serializers.clientSerializer">
        function <span class="apidocSignatureSpan">mosca.serializers.</span>clientSerializer
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clientSerializer(client) {
  return client.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mosca.serializers.packetSerializer" id="apidoc.element.mosca.serializers.packetSerializer">
        function <span class="apidocSignatureSpan">mosca.serializers.</span>packetSerializer
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packetSerializer(packet) {
  var result = {};

  if (packet.messageId) {
    result.messageId = packet.messageId;
  }

  if (packet.topic) {
    result.topic = packet.topic;
  }

  if (packet.qos) {
    result.qos = packet.qos;
  }

  if (packet.unsubscriptions) {
    result.unsubscriptions = packet.unsubscriptions;
  }

  if (packet.subscriptions) {
    result.subscriptions = packet.subscriptions;
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>